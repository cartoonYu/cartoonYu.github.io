<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cartoonyu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"default","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="do what I like, love who I love">
<meta property="og:type" content="website">
<meta property="og:title" content="cartoon&#39;s blog">
<meta property="og:url" content="https://cartoonyu.github.io/index.html">
<meta property="og:site_name" content="cartoon&#39;s blog">
<meta property="og:description" content="do what I like, love who I love">
<meta property="og:locale">
<meta property="article:author" content="cartoon Yu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cartoonyu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>cartoon's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cartoon's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/06/28/JAVA/%E5%AF%B9%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/28/JAVA/%E5%AF%B9%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">对三色标记法的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2025-06-28 10:46:00 / Modified: 02:50:14" itemprop="dateCreated datePublished" datetime="2025-06-28T10:46:00+00:00">2025-06-28</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在回看 JVM 的相关概念，看到了三色标记法的使用，所以就记录一下。</p>
<h2 id="三色标记法是什么"><a href="#三色标记法是什么" class="headerlink" title="三色标记法是什么"></a>三色标记法是什么</h2><p>在可达性分析的过程中，对象有且只有三种状态：完全没被扫描，对象被扫描但子对象还没完全被扫描，对象与其子对象都被扫描了。</p>
<p>而这三种状态即为三种颜色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">白色：完全没被扫描。对象与子对象确定被回收。</span><br><span class="line">灰色：对象被扫描但子对象还没完全被扫描。根对象确定存活，子对象可能被回收。</span><br><span class="line">黑色：对象与其子对象都被扫描了。对象与子对象确定存活。</span><br></pre></td></tr></table></figure>



<h2 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h2><p>三色标记法是对堆上的对象进行归类，简化可达性分析中的重复扫描的工作量。</p>
<h2 id="作用阶段"><a href="#作用阶段" class="headerlink" title="作用阶段"></a>作用阶段</h2><p>作用阶段包括初始标记与并发标记。</p>
<p>初始标记主要是确定 GC Root ，并把根节点标为灰色。初始标记需要暂停用户线程。</p>
<p>并发标记主要是根据 GC Root 往下扫描子对象，将子对象从白色扭转为黑色&#x2F;灰色。并发标记过程标记线程与用户线程并行。</p>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>在进行回收前，对象有且只会存在两个颜色：黑色以及白色。<br>但由于扫描所有对象耗时久，所以扫描只能与用户线程并发，并发过程中会发生对象图关系的改变，会出现两个问题</p>
<ol>
<li>黑色对象变成了白色对象，最终应该被回收但未被回收，俗称浮动垃圾，下一次回收也行。</li>
<li>白色对象变成了黑色对象，最终不应被回收却被回收了，会导致程序异常。</li>
</ol>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>白色对象变成黑色对象的原因，需要同时满足下面两个：</p>
<ol>
<li>黑色根对象增加了对上述白色对象的引用。</li>
<li>灰色根对象删除对白色子对象引用。</li>
</ol>
<p>最后的结果是：白色对象实际上是黑色对象，但回收程序仍认为是白色对象。</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>针对上述的变动，解决办法有两个：</p>
<ol>
<li>增量更新：记录黑色根对象对白色对象的新增调用，并且以黑色根对象为根重新扫描这部分的引用。</li>
<li>原始快照：记录灰色根对象删除对白色子对象的删除，并且重新扫描整个对象图。</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">增量更新</th>
<th align="left">原始快照</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="left">扫描范围小，最终标记过程停顿时间短</td>
<td align="left">不会产生浮动垃圾，根据对象图重新扫描</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">产生新的浮动垃圾。仅记录新增引用，未记录删除引用</td>
<td align="left">最终标记时间长。扫描了整个对象图</td>
</tr>
<tr>
<td align="center">适用范围</td>
<td align="left">老年代。老年代对象引用变化少，上述缺点出现概率低</td>
<td align="left">基于 Region 实现的垃圾收集器</td>
</tr>
</tbody></table>
<h2 id="最后的叨叨"><a href="#最后的叨叨" class="headerlink" title="最后的叨叨"></a>最后的叨叨</h2><blockquote>
<p> 为什么会有并发标记与最终标记两阶段</p>
</blockquote>
<p>我觉得主要是为了尽可能缩短 STW 的时间。</p>
<p>两阶段更像是二八原则的具象化。80%对象关系不会变化，20%对象关系会变化（实际上更少）。</p>
<p>针对不会变化的部分，并发标记能减少业务感知的时间。针对变化的部分，则记录下来再 STW 确定最终引用关系。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/06/01/JAVA/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/01/JAVA/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">并发更新变量的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-01 16:39:09" itemprop="dateCreated datePublished" datetime="2025-06-01T16:39:09+00:00">2025-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到一个很有意思的问题，如下代码在多线程运行下的问题与解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private static int count = 0;</span><br><span class="line">    </span><br><span class="line">    public static void increment() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="变量累加的过程"><a href="#变量累加的过程" class="headerlink" title="变量累加的过程"></a>变量累加的过程</h2><p>由 Java 的内存模型可知，变量的累加经历三个阶段：从主内存读取到工作内存 -&gt; 工作内存中修改 -&gt; 写回主内存</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>由上述三步可知，可能存在问题有三个：</p>
<ol>
<li>读取的值是否为当前时刻的最新值</li>
<li>累加的前提值是否为当前时刻的最新值</li>
<li>写回主内存是否为当前时刻期望值</li>
</ol>
<p>问题 1 ，一定是。因为变量存在于内存某一块区域，任何时刻的读取都是对该内存的读取。</p>
<p>问题 2，不一定是。经历了复制到工作内存的阶段，工作内存和主内存的值不能保证强一致。</p>
<p>问题 3，不一定是。因为累加的前提值不准确以及多线程同时写回的顺序问题，所以修改后的值与期望值可能不一致。</p>
<p>所以问题的关键是：如何保证工作内存读取的是最新值，如何保证写回主内存是顺序的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><p>本地分为两种：自旋尝试更新 &amp; 顺序更新，分别对应 CAS 更新以及锁后顺序更新。</p>
<h4 id="CAS-更新"><a href="#CAS-更新" class="headerlink" title="CAS 更新"></a>CAS 更新</h4><p>CAS 更新分为两种，AtomicInteger 以及 LongAddr。</p>
<p>AtomicInteger 应该都很熟悉，利用 volatile 关键字保证变量的可见性，自旋使用 Unsafe 提供的原子指令保证更新的准确性。</p>
<p>LongAddr 则是使用 Cell 数组保存更新指令，后续通过 sum 方法提供当前的计算结果。</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">AtomicInteger</th>
<th align="center">LongAddr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">计算结果</td>
<td align="center">实时</td>
<td align="center">非实时</td>
</tr>
<tr>
<td align="center">作用原理</td>
<td align="center">时间换空间（针对单变量的自旋更新）</td>
<td align="center">空间换时间（针对 Cell 数组的 CAS 更新）</td>
</tr>
<tr>
<td align="center">冲突概率</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
</tbody></table>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁分为两种：synchronized 以及 ReentrantLock。</p>
<p>synchronized 通过 monitor enter &amp; monitor exit 内存屏障实现锁的获取与释放。</p>
<p>ReentrantLock 通过 AQS 队列保证锁获取&#x2F;释放的顺序。</p>
<h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">synchronized</th>
<th align="center">ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本性质</td>
<td align="center">Java 关键字</td>
<td align="center">Java API</td>
</tr>
<tr>
<td align="center">实现方式</td>
<td align="center">内存屏障</td>
<td align="center">AQS（底层 CAS 更新）</td>
</tr>
<tr>
<td align="center">公平性控制</td>
<td align="center">只支持非公平锁</td>
<td align="center">公平锁&#x2F;非公平锁</td>
</tr>
<tr>
<td align="center">多条件绑定</td>
<td align="center">单个条件绑定</td>
<td align="center">多 Condition 绑定</td>
</tr>
<tr>
<td align="center">锁是否可升级</td>
<td align="center">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</td>
<td align="center">公平锁&#x2F;非公平锁</td>
</tr>
<tr>
<td align="center">使用复杂度</td>
<td align="center">低，不用考虑锁获取&#x2F;释放过程</td>
<td align="center">高，需要手动获取&#x2F;释放锁</td>
</tr>
<tr>
<td align="center">使用灵活度</td>
<td align="center">低</td>
<td align="center">高，可支持超时获取锁、尝试获取锁，锁中断的操作</td>
</tr>
</tbody></table>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="Redis-increment-操作"><a href="#Redis-increment-操作" class="headerlink" title="Redis increment 操作"></a>Redis increment 操作</h4><p>针对单个 redis key 做递增的操作。因为 Redis 操作是单线程的，所以本质上利用了 Redis 顺序操作的特性。</p>
<h4 id="ZooKeeper-顺序节点"><a href="#ZooKeeper-顺序节点" class="headerlink" title="ZooKeeper 顺序节点"></a>ZooKeeper 顺序节点</h4><p>针对每次操作新增一个临时节点。通过计算序号的大小得到最终的结果。</p>
<h4 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Redis increment</th>
<th align="center">Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td align="center">计算结果</td>
<td align="center">实时</td>
<td align="center">非实时（事后计算结果）</td>
</tr>
<tr>
<td align="center">作用原理</td>
<td align="center">顺序更新</td>
<td align="center">对节点进行计数</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">高</td>
<td align="center">低，涉及节点新增与清除</td>
</tr>
</tbody></table>
<h2 id="为什么有意思"><a href="#为什么有意思" class="headerlink" title="为什么有意思"></a>为什么有意思</h2><p>之前对于该问题，最常用就是 CAS&#x2F;锁（本地），Redis（分布式）。优点是强一致，缺点是可能的自旋等待带来的性能损耗。（时间换空间，强一致）</p>
<p>如果只要最终一致但提升性能，只能暂存中间结果最后累加，但是自己实现又涉及操作升级、扩容等管理，而 Striped64 子类则实现了上述功能。（空间换时间，最终一致）</p>
<p>之前没有将最终一致的可行性与该问题联系到一起，而这也是我觉得有意思的地方。系统设计的 trade-off 体现得尤其明显。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/05/30/spring/%E8%A7%A3%E5%86%B3%E5%9B%A0%E9%94%99%E8%AF%AF%20Mock%20%E5%AF%BC%E8%87%B4%E5%8D%95%E6%B5%8B%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/30/spring/%E8%A7%A3%E5%86%B3%E5%9B%A0%E9%94%99%E8%AF%AF%20Mock%20%E5%AF%BC%E8%87%B4%E5%8D%95%E6%B5%8B%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">解决因错误 Mock 导致单测慢的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-30 01:04:26" itemprop="dateCreated datePublished" datetime="2025-05-30T01:04:26+00:00">2025-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然发现单元测试运行的比较慢，比较有意思，所以就深究了一下源码，解决了一下。</p>
<h2 id="解决前后对比"><a href="#解决前后对比" class="headerlink" title="解决前后对比"></a>解决前后对比</h2><p>解决前，单测本地运行 10+ 分钟。</p>
<p>解决后，单测本地运行 1 分钟。</p>
<h2 id="项目概况"><a href="#项目概况" class="headerlink" title="项目概况"></a>项目概况</h2><p>SpringBoot 版本：2.3.x，junit 版本：5.x。</p>
<p>项目结构很简单：接收上游请求查询数据库做业务逻辑。</p>
<p>单测同时使用 @InjectMocks + @Spy&#x2F;@Mock 以及 @SpyBean&#x2F;@MockBean 对下游依赖进行 mock。</p>
<h2 id="运行时表现"><a href="#运行时表现" class="headerlink" title="运行时表现"></a>运行时表现</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>单元测试逻辑运行很快，运行前Spring 容器不断被启动，数据库连接 &#x2F; Bean 被重复加载。</p>
<p>而在普通业务项目中，运行时数据库 &#x2F; Bean 的信息是确定的，重复加载并没有意义。</p>
<h3 id="重复加载的-demo"><a href="#重复加载的-demo" class="headerlink" title="重复加载的 demo"></a>重复加载的 demo</h3><p>所有单测都继承 BaseTest 基类，使用集成测试的方式运行所有单测。</p>
<h4 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MockOuterService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private MockService mockService;</span><br><span class="line">    </span><br><span class="line">    public String mockString()&#123; return mockService.mockString();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface MockService &#123;</span><br><span class="line">    String mockString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class MockServiceImpl implements MockService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String mockString() &#123;return &quot;business return&quot;;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//测试基类</span><br><span class="line">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span><br><span class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE, classes = SpringServiceTestApplication.class)</span><br><span class="line">@ExtendWith(MockitoExtension.class)</span><br><span class="line">public class BaseTest &#123;&#125;</span><br><span class="line"></span><br><span class="line">//集成测试</span><br><span class="line">@RunWith(JUnitPlatform.class)</span><br><span class="line">@SelectPackages(&quot;org.spring.demo.demo&quot;)</span><br><span class="line">public class TestAll extends BaseTest &#123;&#125;</span><br><span class="line"></span><br><span class="line">//业务测试 1</span><br><span class="line">class Test1 extends BaseTest &#123;</span><br><span class="line">    @InjectMocks</span><br><span class="line">    @Resource</span><br><span class="line">    private MockOuterService mockOuterService;</span><br><span class="line"></span><br><span class="line">    @Spy</span><br><span class="line">    private MockService mockService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void test()&#123;</span><br><span class="line">        Mockito.when(mockService.mockString()).thenReturn(&quot;test1 mock&quot;);</span><br><span class="line">        System.out.println(mockOuterService.mockString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//业务测试 2</span><br><span class="line">class Test2 extends BaseTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @SpyBean</span><br><span class="line">    private MockService mockService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MockOuterService mockOuterService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void test()&#123;</span><br><span class="line">        Mockito.when(mockService.mockString()).thenReturn(&quot;test2 mock&quot;);</span><br><span class="line">        System.out.println(mockOuterService.mockString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p>Spring Boot Banner 出现两次，容器被启动两次。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/202505171114503.png"></p>
<h2 id="重复加载原因"><a href="#重复加载原因" class="headerlink" title="重复加载原因"></a>重复加载原因</h2><h3 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h3><p>Spring 是一个依赖上下文的框架，若上下文缓存失效&#x2F;配置变更则会重新刷新上下文，从而引发容器重启。</p>
<h3 id="推测原因"><a href="#推测原因" class="headerlink" title="推测原因"></a>推测原因</h3><p>业务项目启动过程中，Spring Boot Banner 出现一次，且所有资源（数据库连接池&#x2F;动态线程池）只初始化一遍。</p>
<p>而在单测过程中启动多次，有可能是单测改变了 Spring 上下文，或者单测与业务代码结合有问题。</p>
<h3 id="最小可行性分析"><a href="#最小可行性分析" class="headerlink" title="最小可行性分析"></a>最小可行性分析</h3><p>在对单测删减到最后两个类，仅使用 @MockBean 或者 @InjectMocks&#x2F;@Mock 时，容器启动一次。同时使用，容器启动两次。</p>
<p>所以原因应该是 SpringBoot 封装的与 Mockito 原生的同时作用情况下，改变了 Spring 的上下文。</p>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><h4 id="MockBean-x2F-SpyBean-作用原理"><a href="#MockBean-x2F-SpyBean-作用原理" class="headerlink" title="@MockBean&#x2F;@SpyBean 作用原理"></a>@MockBean&#x2F;@SpyBean 作用原理</h4><p>整体流程分为注册与使用两部份。</p>
<p>注册方面</p>
<ol>
<li>Junit 通过 Extension 形式提供单元测试各执行流程的自定义逻辑扩展能力。</li>
<li>Spring 自定义 Extension 子类 SpringExtension，并通过执行不同 TestExecutionListener 执行 TestContextManager 自定义内容。</li>
<li>Spring 通过 ContextCustomizerFactory 形式提供动态修改上下文的能力，SpringBoot test 实现子类用于 Mock 相关逻辑实现。</li>
<li>SpringBoot test自定义 ContextCustomizerFactory 子类 MockitoContextCustomizerFactory，用于 Mock 相关逻辑实现。</li>
</ol>
<p>使用方面</p>
<p>Junit 通过执行不同 Extension 实现自定义逻辑，进而一层层触发到 SpringBoot test 实现的 Mock 相关逻辑。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/202505272303876.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">group 注册扩展</span><br><span class="line">    group junit5 内部流程</span><br><span class="line">        &quot;MethodBasedTestDescriptor&quot; -&gt; &quot;ExtensionUtils&quot;: 扫描 @Test，调用 Extension 注册</span><br><span class="line">        &quot;ExtensionUtils&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 调用注册</span><br><span class="line">        &quot;MutableExtensionRegistry&quot; -&gt; &quot;SpringExtension&quot;: 注册 Extension</span><br><span class="line">    end</span><br><span class="line">    group Spring Framework 逻辑</span><br><span class="line">        &quot;SpringExtension&quot; -&gt; &quot;TestContextManager&quot;: 新建 TestContextManager</span><br><span class="line">        &quot;TestContextManager&quot; -&gt; &quot;BootstrapUtils&quot;: 触发 @BootstrapWith 扫描逻辑</span><br><span class="line">        &quot;BootstrapUtils&quot; -&gt; &quot;TestContextManager&quot;: 返回启动类</span><br><span class="line">        &quot;TestContextManager&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 触发启动类 buildTestContext</span><br><span class="line">    end</span><br><span class="line">    group SpringBoot 逻辑</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 扫描执行 ContextCustomizerFactory 逻辑</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;MockitoContextCustomizerFactory&quot;: Mockito 自定义上下文类</span><br><span class="line">        &quot;MockitoContextCustomizerFactory&quot; -&gt; &quot;DefinitionsParser&quot;: 注册注解扫描器</span><br><span class="line">        &quot;DefinitionsParser&quot; -&gt; &quot;DefinitionsParser&quot;: 扫描 @SpyBean/@MockBean 添加到 Definition 集合中</span><br><span class="line">        &quot;DefinitionsParser&quot; -&gt; &quot;MockitoContextCustomizerFactory&quot;: 返回 Definition 集合</span><br><span class="line">        &quot;MockitoContextCustomizerFactory&quot; -&gt; &quot;MockitoContextCustomizerFactory&quot;: 以 Definition 集合构建 ContextCustomizer</span><br><span class="line">        &quot;MockitoContextCustomizerFactory&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 返回 ContextCustomizer</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 构建 MergedContextConfiguration</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 构建 TestContext</span><br><span class="line">    end </span><br><span class="line">    &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;TestContextManager&quot;: 返回 TestContext</span><br><span class="line">    &quot;TestContextManager&quot; -&gt; &quot;TestContextManager&quot;: 存储上下文</span><br><span class="line">    &quot;TestContextManager&quot; -&gt; &quot;SpringExtension&quot;: 返回 TestContextManager 实例</span><br><span class="line">    &quot;SpringExtension&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 返回 SpringExtension 实例</span><br><span class="line">    &quot;MutableExtensionRegistry&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 存储各 Extension 实例</span><br><span class="line">end</span><br><span class="line">group 使用扩展</span><br><span class="line">    &quot;NodeTestTask&quot; -&gt; &quot;ClassBasedTestDescriptor&quot;: prepare</span><br><span class="line">    &quot;ClassBasedTestDescriptor&quot; -&gt; &quot;SpringExtension&quot;: TestInstancePostProcessor#postProcessTestInstance </span><br><span class="line">    &quot;SpringExtension&quot; -&gt; &quot;TestContextManager&quot;: prepareTestInstance</span><br><span class="line">    &quot;TestContextManager&quot; -&gt; &quot;DependencyInjectionTestExecutionListener&quot;: 传入 SpringBootTestContextBootstrapper 构建的 TestContext 到 prepareTestInstance</span><br><span class="line">    &quot;DependencyInjectionTestExecutionListener&quot; -&gt; &quot;DependencyInjectionTestExcutionListener&quot;: 创建完整 Spring Bean 依赖</span><br><span class="line">end</span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="InjectMocks-Spy-x2F-Mock-作用原理"><a href="#InjectMocks-Spy-x2F-Mock-作用原理" class="headerlink" title="@InjectMocks +@Spy&#x2F;@Mock 作用原理"></a>@InjectMocks +@Spy&#x2F;@Mock 作用原理</h4><p>整体流程分为注册与使用两部份。</p>
<p>注册方面，只是将自定义扩展挂载到 Junit 钩子上。</p>
<p>使用方面，扫描当前单测类相关注释，反射注入新增的 mock 对象。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/202505300027369.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">group 注册扩展</span><br><span class="line">    group junit5 内部流程</span><br><span class="line">        &quot;MethodBasedTestDescriptor&quot; -&gt; &quot;ExtensionUtils&quot;: 扫描 @Test，调用 Extension 注册</span><br><span class="line">        &quot;ExtensionUtils&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 调用注册</span><br><span class="line">        &quot;MutableExtensionRegistry&quot; -&gt; &quot;MockitoExtension&quot;: 注册 Extension</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">group 使用扩展</span><br><span class="line">    group junit5 内部流程</span><br><span class="line">        &quot;NodeTestTask&quot; -&gt; &quot;TestMethodTestDescriptor&quot;: execute</span><br><span class="line">        &quot;TestMethodTestDescriptor&quot; -&gt; &quot;TestMethodTestDescriptor&quot;: TestMethodTestDescriptor#invokeBeforeEachCallbacks </span><br><span class="line">        &quot;TestMethodTestDescriptor&quot; -&gt; &quot;MockitoExtension&quot;: beforeEach</span><br><span class="line">    end</span><br><span class="line">    group mockito 内部流程</span><br><span class="line">        &quot;MockitoExtension&quot; -&gt; &quot;DefaultMockitoSessionBuilder&quot;: startMocking</span><br><span class="line">        &quot;DefaultMockitoSessionBuilder&quot; -&gt; &quot;DefaultMockitoSession&quot;: new DefaultMockitoSession Object </span><br><span class="line">        &quot;DefaultMockitoSession&quot; -&gt; &quot;MockitoAnnotations&quot;: openMocks</span><br><span class="line">        &quot;MockitoAnnotations&quot; -&gt; &quot;InjectingAnnotationEngine&quot;: process</span><br><span class="line">        &quot;InjectingAnnotationEngine&quot; -&gt; &quot;MockScanner&quot;: processIndependentAnnotations/injectCloseableMocks 传入当前单测类</span><br><span class="line">        &quot;MockScanner&quot; -&gt; &quot;MockScanner&quot;: 扫描修饰 @Mock/@Spy 变量</span><br><span class="line">        &quot;MockScanner&quot; -&gt; &quot;InjectingAnnotationEngine&quot;: 返回扫描结果</span><br><span class="line">        &quot;InjectingAnnotationEngine&quot; -&gt; &quot;InjectingAnnotationEngine&quot;: 执行 mock 注入</span><br><span class="line">        &quot;InjectingAnnotationEngine&quot; -&gt; &quot;DefaultInjectionEngine&quot;: injectMocksOnFields 反射注入</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二者原理区别"><a href="#二者原理区别" class="headerlink" title="二者原理区别"></a>二者原理区别</h3><table>
<thead>
<tr>
<th></th>
<th align="center">SpringBoot</th>
<th align="left">Mockito 原生</th>
</tr>
</thead>
<tbody><tr>
<td>执行时机</td>
<td align="center">单测类初始化（ClassBasedTestDescriptor）</td>
<td align="left">单测方法（TestMethodTestDescriptor）</td>
</tr>
<tr>
<td>注入对象</td>
<td align="center">缓存的 Spring Bean</td>
<td align="left">调用 Java 原生反射构建</td>
</tr>
</tbody></table>
<h3 id="原因确定"><a href="#原因确定" class="headerlink" title="原因确定"></a>原因确定</h3><p>根据二者的作用原理可知，Mockito 将 Spring Bean 依赖链改变，进而引发 Spring 容器的启动。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>根据原因可知，解决方案二选一：SpringBoot 的&#x2F;Mockito 原生的。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">SpringBoot</th>
<th align="center">Mockito 原生</th>
</tr>
</thead>
<tbody><tr>
<td align="center">针对对象</td>
<td align="center">Spring Bean</td>
<td align="center">所有的对象</td>
</tr>
<tr>
<td align="center">使用复杂度</td>
<td align="center">低，不需管理依赖链</td>
<td align="center">高，需要手动注入被依赖的对象</td>
</tr>
<tr>
<td align="center">作用场景</td>
<td align="center">需 Spring 环境的集成测试</td>
<td align="center">纯单元测试</td>
</tr>
</tbody></table>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为项目中使用 SpringBoot ，并且单元测试大多以集成测试的方式运行，结合使用的复杂度，所以选择了 SpringBoot 提供的方案。</p>
<h2 id="仍需提升的"><a href="#仍需提升的" class="headerlink" title="仍需提升的"></a>仍需提升的</h2><p>目前 <strong><code>junit-platform.properties</code></strong> 配置的策略为测试类串行&#x2F;测试方法并行，希望改成测试类并行&#x2F;测试方法并行，进一步提升速度。</p>
<p>但修改后发现大部份单测都报错了，仍需明确原因，推测是各单测自定义 mock 行为互相影响导致。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>通过表象猜测原因，通过源码证明猜想。</p>
<p>在猜测原因时，就在想 SpringBoot 不可能只为了 KPI 而集成 Mockito，肯定有结合 Mockito 做对应的集成，方便后续使用。</p>
<p>追查源码后印证了猜想，满足。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/02/05/JAVA/synchronized,%20volatile%20%E5%9C%A8%20DCL%20%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/05/JAVA/synchronized,%20volatile%20%E5%9C%A8%20DCL%20%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">synchronized, volatile 在 DCL 的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-05 08:00:06" itemprop="dateCreated datePublished" datetime="2025-02-05T08:00:06+00:00">2025-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在看设计模式，在单例模式的 Double Check Lock（DCL）中，存在两个关键字：volatile &amp; synchronized。</p>
<p>之前都知道 DCL 怎么写，直接套娃。但是这两关键字在单例里面的作用还没深究过，于是就自言自语一篇文章。</p>
<h2 id="单例模式代码"><a href="#单例模式代码" class="headerlink" title="单例模式代码"></a>单例模式代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Single</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//first check object</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//locks in the class dimension</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Single.class)&#123;</span><br><span class="line">                <span class="comment">//second check object</span></span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Single</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="synchronized-amp-volatile-作用"><a href="#synchronized-amp-volatile-作用" class="headerlink" title="synchronized &amp; volatile 作用"></a>synchronized &amp; volatile 作用</h2><h3 id="synchronized-作用"><a href="#synchronized-作用" class="headerlink" title="synchronized 作用"></a>synchronized 作用</h3><p>synchronized 是 java 的重量级锁，可作用于方法维度、代码块维度。具体到底层字节码就是 monitor enter &amp; monitor exit。 </p>
<h3 id="volatile-作用"><a href="#volatile-作用" class="headerlink" title="volatile 作用"></a>volatile 作用</h3><p>volatile 有两个作用</p>
<ol>
<li>保证可见性。</li>
</ol>
<p>修饰的变量从主内存 copy 到工作内存，修改后写回到主内存。</p>
<p>作用原理就是读写前 JVM 加一个内存屏障，通过 happen before 原则确保修改可见于读取。</p>
<blockquote>
<p>主内存：类比成 JVM 堆</p>
<p>工作内存：类比成 JVM 虚拟机栈</p>
</blockquote>
<ol start="2">
<li>禁止指令重排序。</li>
</ol>
<h2 id="对象初始化步骤"><a href="#对象初始化步骤" class="headerlink" title="对象初始化步骤"></a>对象初始化步骤</h2><ol>
<li>分配内存空间</li>
<li>实例变量初始化</li>
<li>执行初始化代码块</li>
<li>调用构造函数</li>
<li>静态变量初始化</li>
<li>返回对象引用</li>
</ol>
<p>刨除非必要步骤，上述 6 步剩下 3 步</p>
<ol>
<li>分配内存空间</li>
<li>调用构造函数</li>
<li>返回对象引用</li>
</ol>
<h2 id="synchronized-amp-volatile-在-DCL-缺失的问题"><a href="#synchronized-amp-volatile-在-DCL-缺失的问题" class="headerlink" title="synchronized &amp; volatile 在 DCL 缺失的问题"></a>synchronized &amp; volatile 在 DCL 缺失的问题</h2><h3 id="有-synchronized-没有-volatile"><a href="#有-synchronized-没有-volatile" class="headerlink" title="有 synchronized 没有 volatile"></a>有 synchronized 没有 volatile</h3><p>由于指令重排序的优化手段，上述创建对象的 1 -&gt; 2 -&gt; 3, 可能顺序变成了 1 -&gt; 3 -&gt; 2。</p>
<p>没有禁止重排序，顺序变了，中间的第三步返回是个空对象，并发情况下就 G 了，另一线程拿的是空对象。</p>
<h3 id="有-volatile-没有-synchronized"><a href="#有-volatile-没有-synchronized" class="headerlink" title="有 volatile 没有 synchronized"></a>有 volatile 没有 synchronized</h3><p>并发情况下， A B 两个线程都通过了等于 null 的校验，开始执行创建对象的操作。</p>
<p>上述创建对象说的 1 -&gt; 2 -&gt; 3， A B 两个线程都有可能走完 1 &amp; 2，最后单例对象会是执行慢的线程返回引用的那个。构造函数会执行两遍，违反了单例模式的初衷。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>synchronized &amp; volatile 的作用就很明显。</p>
<p>synchronized 保障构造函数只执行一遍，对象也只有一个。</p>
<p>volatile 保障极端情况下不会返回空对象。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ol>
<li>为什么 synchronized 修饰的是代码块，不是静态方法 getInstance ?</li>
</ol>
<p>为了提升获取单例对象的运行效率。</p>
<p>synchronized 修饰代码块，只会影响进入代码块瞬间的其他线程。</p>
<p>synchronized 修饰方法，会影响调用方法的所有线程。</p>
<ol start="2">
<li>为什么进入 synchronized 修饰代码块后，还要判断一下单例对象是否等于 null ？</li>
</ol>
<p>防止重复创建对象。</p>
<p>假设 A B 两个线程</p>
<ol>
<li>A 线程进入同步块，还在上述说的对象初始化三步里面，B 线程进来了，在 synchronized 代码块外自旋。</li>
<li>A 线程执行完了，B 线程进代码块了，这时若不判断是否为 null，就会重复创建对象。</li>
</ol>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/01/05/JAVA/keepAliveTime%20%E5%90%AB%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/05/JAVA/keepAliveTime%20%E5%90%AB%E4%B9%89/" class="post-title-link" itemprop="url">ThreadPoolExecutor keepAliveTime 含义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-01-05 08:00:06" itemprop="dateCreated datePublished" datetime="2025-01-05T08:00:06+00:00">2025-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在线上环境排查问题时，某个线程池在某个时间点新建线程达到设定的最大线程数 maximumPoolSize，后续流量降低后当前线程数仍未回落，仍然为最大线程数，阻塞队列中有任务，但是活跃线程数显著减少。</p>
<h2 id="之前的认知"><a href="#之前的认知" class="headerlink" title="之前的认知"></a>之前的认知</h2><p>固有的认知中，线程池运行原理：<code>java.util.concurrent.ThreadPoolExecutor#execute</code></p>
<ol>
<li>线程池内部维护 corePoolSize 个线程</li>
<li>任务提交后，若核心线程都已被占用，则添加到阻塞队列</li>
<li>阻塞队列已满，则新建线程直到线程数到达 maximumPoolSize</li>
<li>若阻塞队列已满，并且线程数到达 maximumPoolSize，则执行拒绝策略</li>
<li>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，进行销毁。</li>
</ol>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>认知第五点中：超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，进行销毁。明显与现象不符。现象肯定没问题的，就是认知有问题了：超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，至少不会马上销毁。</p>
<h2 id="现实与认知的问题"><a href="#现实与认知的问题" class="headerlink" title="现实与认知的问题"></a>现实与认知的问题</h2><ol>
<li>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，会不会销毁？</li>
<li>销毁的时机是？</li>
<li>为什么线程池中大多为休眠线程？线程池的线程数仍为最大线程数？</li>
</ol>
<h2 id="重塑认知"><a href="#重塑认知" class="headerlink" title="重塑认知"></a>重塑认知</h2><p>答案都在源码内</p>
<h3 id="ThreadPoolExecutor-执行任务流程"><a href="#ThreadPoolExecutor-执行任务流程" class="headerlink" title="ThreadPoolExecutor 执行任务流程"></a>ThreadPoolExecutor 执行任务流程</h3><h3 id="线程池使用-demo"><a href="#线程池使用-demo" class="headerlink" title="线程池使用 demo"></a>线程池使用 demo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 10, 100, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(1000));</span><br><span class="line">        threadPoolExecutor.execute(() -&gt; System.out.println(&quot;print in thread&quot;));</span><br></pre></td></tr></table></figure>



<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><code>java.util.concurrent.ThreadPoolExecutor#execute</code></p>
<p>流程就是之前认知中 1 - 4 点，在第三点中蕴含一个重要变量：<code>java.util.concurrent.ThreadPoolExecutor#workers</code>，这个就是ThreadPoolExecutor 管理线程的对象</p>
<h3 id="workers-移除流程"><a href="#workers-移除流程" class="headerlink" title="workers 移除流程"></a>workers 移除流程</h3><p>源码上看，只有以下两个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor#addWorkerFailed</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor#processWorkerExit</span><br></pre></td></tr></table></figure>

<p>望文生义，addWorkerFailed 作用为添加 worker 后的失败补偿动作，可以忽略这个方法。</p>
<p>所以正常的销毁动作，肯定是在 processWorkerExit 中。</p>
<h3 id="processWorkerExit-执行流程"><a href="#processWorkerExit-执行流程" class="headerlink" title="processWorkerExit 执行流程"></a>processWorkerExit 执行流程</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>仅在<code>java.util.concurrent.ThreadPoolExecutor#runWorker</code> 中 finally 执行</p>
<p>而 runWorker 则是任务执行的底层方法，那么这意味着：任务执行完，满足某几个前提条件就会销毁线程。那么前提条件是什么呢？</p>
<h4 id="runWorker-执行流程"><a href="#runWorker-执行流程" class="headerlink" title="runWorker 执行流程"></a>runWorker 执行流程</h4><ol>
<li>while 循环调用 <code>java.util.concurrent.ThreadPoolExecutor#getTask</code> 获取任务<ol>
<li>获取到任务后，走真实执行任务流程，beforeExecute&#x2F;run&#x2F;afterExecute</li>
<li>获取不到任务，则到 processWorkerExit 执行</li>
</ol>
</li>
</ol>
<h4 id="getTask-执行流程"><a href="#getTask-执行流程" class="headerlink" title="getTask 执行流程"></a>getTask 执行流程</h4><ol>
<li>使用当前 worker 数与核心线程数关系判定变量 timed</li>
<li>根据 timed 判定 <code>timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take()</code></li>
</ol>
<p>keepAliveTime 第一次出现，并且是用于在当前 worker 数大于核心线程数情况下从阻塞队列中获取元素。</p>
<p>那么，控制 processWorkerExit 执行的前提条件：当前 worker 数大于核心线程数，并且从阻塞队列经过 keepAliveTime 拿不到任务。</p>
<p>但这个前提条件明显跟现象不符，那肯定是 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 中被阻塞了，导致实际获取任务时间 &gt; keepAliveTime。</p>
<h4 id="workQueue-poll-执行流程（以-ArrayBlockingQueue-为例）"><a href="#workQueue-poll-执行流程（以-ArrayBlockingQueue-为例）" class="headerlink" title="workQueue.poll 执行流程（以 ArrayBlockingQueue 为例）"></a>workQueue.poll 执行流程（以 ArrayBlockingQueue 为例）</h4><ol>
<li>获取 ArrayBlockingQueue 全局锁</li>
<li>当队列元素个数 &#x3D; 0， 则 await keepAliveTime 时间</li>
<li>队列元素个数 !&#x3D; 0，出队元素</li>
<li>释放 ArrayBlockingQueue 全局锁</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        long nanos = unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>从workQueue.poll 执行流程中，能明显看到线程 await 的前提是获取到队列的全局锁，并且队列元素 &#x3D; 0。</p>
<p>整理一遍就是：</p>
<p>当线程获取到队列全局锁，并且当前队列为空，await keepAliveTime 后，若当前队列为空，则执行销毁方法。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/20250105161217.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">&quot;Thread&quot; -&gt; &quot;BlockingQueue&quot;: pool task</span><br><span class="line">&quot;Thread&quot; -&gt; &quot;BlockingQueue&quot;: get global ReentrantLock</span><br><span class="line">alt get global ReentrantLock success</span><br><span class="line">    alt BlockingQueue size = 0</span><br><span class="line">        &quot;Thread&quot; -&gt; &quot;Condition&quot;: await keepAliveTime</span><br><span class="line">        &quot;BlockingQueue&quot; -&gt; &quot;Thread&quot;: non task，execute processWorkerExit method</span><br><span class="line">    else</span><br><span class="line">        &quot;BlockingQueue&quot; -&gt; &quot;Thread&quot;: first task in queue</span><br><span class="line">        &quot;Thread&quot; -&gt; &quot;Thread&quot;: keep execute task</span><br><span class="line">    end</span><br><span class="line">else </span><br><span class="line">    &quot;Thread&quot; -&gt; &quot;BlockingQueue&quot;: keep acquire ReentrantLock</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<p>那么上述提到的两个问题</p>
<ol>
<li>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，会不会销毁？</li>
<li>销毁的时机是？</li>
<li>为什么线程池中大多为休眠线程？线程池的线程数仍为最大线程数？</li>
</ol>
<p>就有了答案</p>
<ol>
<li><p>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，有可能销毁，前提是拿到队列的全局锁。</p>
</li>
<li><p>销毁的时机是当前线程获取到队列全局锁，并且队列元素 &#x3D; 0，并且 await 后队列元素仍然为 0</p>
</li>
<li><p>因为线上提交任务刚好够核心线程消费，并且残留少数任务在阻塞队列中。在并发情况下，大部分线程都 await，线程池只能新增 worker 处理了。</p>
</li>
</ol>
<h2 id="自言自语"><a href="#自言自语" class="headerlink" title="自言自语"></a>自言自语</h2><h3 id="怎么解决当前线程数-x3D-最大线程数，并且活跃线程较少的情况？"><a href="#怎么解决当前线程数-x3D-最大线程数，并且活跃线程较少的情况？" class="headerlink" title="怎么解决当前线程数 &#x3D; 最大线程数，并且活跃线程较少的情况？"></a>怎么解决当前线程数 &#x3D; 最大线程数，并且活跃线程较少的情况？</h3><ol>
<li>调高 corePoolSize ，使线程池不新增 corePoolSize 之外的线程。</li>
<li>调低 keepAliveTime &amp; TimeUnit 的值，使休眠线程快速被销毁。</li>
</ol>
<p>在商业开发的角度上，比较难精准实现。</p>
<ol>
<li>业务发展速度很快， corePoolSize 在将来的一段时间内就不适合了。</li>
<li>加快休眠线程的销毁，意味着存在频繁新建线程的问题，会影响系统稳定性。</li>
</ol>
<h3 id="为什么-await-keepAliveTime后不直接销毁？还尝试出队元素？"><a href="#为什么-await-keepAliveTime后不直接销毁？还尝试出队元素？" class="headerlink" title="为什么 await keepAliveTime后不直接销毁？还尝试出队元素？"></a>为什么 await keepAliveTime后不直接销毁？还尝试出队元素？</h3><p>这就回到 java 线程与操作系统线程的映射关系。</p>
<p>线程模型有三种：一对一，多对一，一对多。java 在大多数平台上都是一对一。</p>
<ol>
<li>如果直接销毁，核心线程处理不过来情况下，线程池会频繁销毁&#x2F;新建线程，消耗系统的资源。</li>
<li>尝试出队元素，double check 线程池的负载，负载高则继续处理，负载较低则销毁线程，达到节省资源的目的。</li>
</ol>
<h3 id="keepAliveTime-的理解"><a href="#keepAliveTime-的理解" class="headerlink" title="keepAliveTime 的理解"></a>keepAliveTime 的理解</h3><p>源码中的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</span><br><span class="line"></span><br><span class="line">当线程数大于 Core 数时，这是多余的空闲线程在终止之前等待新任务的最长时间。</span><br></pre></td></tr></table></figure>

<p>之前以为是线程数大于 Core 数时，空闲线程的存活时间。过了 keepAliveTime 就执行销毁。</p>
<p>现在认识到：线程数大于 Core 数时，空闲线程的存活时间 &gt;&#x3D; keepAliveTime （没获取到队列锁的情况下），并且销毁前 double check 是否有任务，没有才执行销毁。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2023/11/05/cache/Redis%20%E7%9A%84%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/05/cache/Redis%20%E7%9A%84%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Redis 的三种部署模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-05 17:35:40" itemprop="dateCreated datePublished" datetime="2023-11-05T17:35:40+00:00">2023-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>提前叠个 buff：这个文章不涉及图（画起来比较麻烦），只是记录我的胡思乱想。</p>
<blockquote>
<p>redis 从单点 -&gt; 集群总共有三个部署模式：单机模式，主从模式，哨兵模式，集群模式</p>
</blockquote>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>新手入门模式。单机模式意味着 Redis 是单点的，部署在一台服务器，挂了就挂了，用在本地测试还可以，但是生产环境就算了。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>部署简单</li>
<li>省钱，一台服务器就可以了</li>
<li>不涉及主从复制等，数据强一致</li>
</ol>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>单点意味着稳定性基本上为 0，挂了就挂了</li>
<li>吞吐量受限于单机资源</li>
</ol>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>当流量越来越大，单台机器资源不能无限增长，就需要水平扩展到多个节点，使用多个节点分散承接读流量。</p>
<p>主从模式为主节点承接写流量，从节点承接读流量，二者数据一致通过主节点异步复制（全量复制 &#x2F; 增量复制）到从节点。</p>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol>
<li>读流量被分摊到多个节点上，读流量支持力度变大</li>
<li>当主节点宕机&#x2F;不可用时，可以手动切换主节点继续提供服务</li>
</ol>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>当主节点宕机&#x2F;不可用时手动切换节点，切换过程中 redis （主节点）不可用，并且会丢失主节点 &#x2F; 从节点之间未同步的数据</li>
<li>稳定性还是不够，依赖手动切换。不适用于生产。</li>
<li>写流量还是让主节点独自承受，写流量还是靠单机资源支撑</li>
</ol>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式主要解决主从模式中手动切换的部分，本质上哨兵代替了人，通过 gossip 协议监控主节点的健康情况。</p>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><ol>
<li>不用手动切换主节点了，切换过程中虽然 redis 也是不可用的，但是这个时间会极大的降低</li>
</ol>
<h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>sentinel 与主节点多了一层心跳检测，有可能 sentinel 与主节点的网络抖动导致重新选举主节点。</li>
<li>redis 主从节点吞吐因心跳检测可能稍微降低。</li>
</ol>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>集群模式主要解决了两个问题：写流量水平扩展 &amp; 哨兵与主节点的网络抖动。</p>
<p>集群模式主要的架构为：主节点平分 16384 个槽，集群支持主节点的动态上线&#x2F;下线（需要 rehash），主节点与从节点通过心跳关联，主节点失联后从节点有权发起选举成为主节点（raft 算法）。</p>
<h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><ol>
<li>自管理集群内主从节点上下线，减少因外部集群网络抖动之类的发起的无效选举</li>
<li>数据按照 slot 存放在多个节点，客户端通过服务端主节点的重定向跳转到具体的槽，可动态调整数据分布</li>
<li>减少了集群整体不可用的概率，某一主节点宕机只影响一部分数据的访问</li>
<li>写流量 &amp; 数据平分到多个节点，集群的写请求瓶颈得到缓解</li>
</ol>
<h4 id="劣势-3"><a href="#劣势-3" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>集群间状态同步使用 gossip 协议，节点数较多存在较多的心跳网络流量</li>
<li>主节点的上线&#x2F;下线需要进行 rehash ，当节点内数据较多耗时较长</li>
</ol>
<blockquote>
<p>redis 节点间复制有两种：全量复制 &amp; 部分复制</p>
</blockquote>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><h4 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h4><ol>
<li>从节点刚上线需要同步主节点的数据</li>
<li>从节点切换脑裂后从节点偏移量与主节点不一致的时间点</li>
<li>从节点偏移量不在主节点的复制缓冲区中</li>
</ol>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>从节点向主节点发起同步数据的请求</li>
<li>主节点通过 bgsave 形成当前数据的快照，发给从节点</li>
<li>从节点删除历史数据，加载主节点发过来 RDB 文件</li>
<li>从节点拉取主节点缓冲区数据，加载到自身的内存中，并更新当前的偏移量</li>
</ol>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><h4 id="出现场景-1"><a href="#出现场景-1" class="headerlink" title="出现场景"></a>出现场景</h4><ol>
<li>全量复制出现场景之外的场景</li>
<li>主从日常复制</li>
</ol>
<p>过程</p>
<ol>
<li>主节点将命令同步到缓冲区（AOF）</li>
<li>从节点拉取缓冲区数据，更新到自身的节点中，并更新当前的偏移量</li>
</ol>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2023/06/10/cache/%E8%80%81%E8%AF%9D%E6%96%B0%E8%B0%88%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/cache/%E8%80%81%E8%AF%9D%E6%96%B0%E8%B0%88%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">老话新谈之缓存一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-10 17:05:42" itemprop="dateCreated datePublished" datetime="2023-06-10T17:05:42+00:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>缓存一致性常见的更新策略也比较多，如先更新数据库再更新缓存，先删缓存再更新数据库等等，我在理解的时候有些混乱，所以这个文章提供了一些理解上的技巧去理解缓存一致性。</p>
<h3 id="为什么会有缓存一致性的问题"><a href="#为什么会有缓存一致性的问题" class="headerlink" title="为什么会有缓存一致性的问题"></a>为什么会有缓存一致性的问题</h3><ol>
<li>缓存与数据库是两套中间件，存在网络抖动之类的原因导致没有更新任一方的可能</li>
<li>数据库大多都是事务型的中间件，支持错误回滚，缓存大多是非事务型的中间件，这里缓存更新失败了没办法回滚</li>
</ol>
<p>所以根因是缓存大部分不支持事务无法回滚。</p>
<h3 id="怎么尽量解决缓存一致性的问题"><a href="#怎么尽量解决缓存一致性的问题" class="headerlink" title="怎么尽量解决缓存一致性的问题"></a>怎么尽量解决缓存一致性的问题</h3><p>操作二者必定有先后顺序，存在以下两个情况：</p>
<ol>
<li>先操作缓存，再操作数据库。操作缓存成功，数据库更新失败，缓存无法回滚，数据不一致</li>
<li>先操作数据库，再操作缓存。操作数据库成功，缓存操作失败，可触发异常回滚数据库，数据一致</li>
</ol>
<p>根据上述所列，只能先操作数据库，再操作缓存了。</p>
<p>操作缓存也分两种：</p>
<ol>
<li>更新缓存数据，可能并发请求，后一请求更新缓存的数据被前一请求的更新覆盖了，导致数据不一致</li>
<li>删除缓存数据，并发请求，二者都使缓存失效，查询请求将数据库数据加载到缓存中，数据一致</li>
</ol>
<p>根据上述所列，只能使缓存失效，查询请求加载数据到缓存中了。</p>
<blockquote>
<p>所以，如果在不加任何重试措施的情况下，先操作数据库，再删除缓存是一个容错较好的方法。</p>
</blockquote>
<h3 id="缓存一致性的分类-amp-存在的问题"><a href="#缓存一致性的分类-amp-存在的问题" class="headerlink" title="缓存一致性的分类 &amp; 存在的问题"></a>缓存一致性的分类 &amp; 存在的问题</h3><h4 id="Client-维护缓存-amp-数据库的一致性"><a href="#Client-维护缓存-amp-数据库的一致性" class="headerlink" title="Client 维护缓存 &amp; 数据库的一致性"></a>Client 维护缓存 &amp; 数据库的一致性</h4><ol>
<li><p>更新缓存 -&gt; 更新数据库</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230606213304.png" alt="图片1"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; Cache: update data</span><br><span class="line">transaction1 &lt;-- Cache: update result</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; DB: update data</span><br><span class="line">transaction1 &lt;-- DB: update result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<ul>
<li>可能出现的数据不一致</li>
</ul>
<p>​    数据不一致：更新缓存成功了，更新数据库失败了，有数据不一致的问题，直到缓存超时失效或又一更新请求操作成功都会不一致</p>
<ul>
<li><p>改进方式</p>
<p>若保证更新数据仅有少数的服务更新，可以将更新数据库请求入队处理，且可加入重试机制。但是队列的加入会增大系统复杂度，并且重试以及缓存更新顺序不一致会加剧数据不一致</p>
</li>
</ul>
<ol start="2">
<li>更新数据库 -&gt; 更新缓存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230606215720.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; DB: update data</span><br><span class="line">transaction1 &lt;-- DB: update result</span><br><span class="line"></span><br><span class="line">transaction2 -&gt; DB: update data</span><br><span class="line">transaction2 &lt;-- DB: update result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transaction2 -&gt; Cache: update data</span><br><span class="line">transaction2 &lt;-- Cache: update result</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; Cache: update data</span><br><span class="line">transaction1 &lt;-- Cache: update result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li>可能出现的数据不一致</li>
</ul>
<p>​        数据不一致：如 t1 先更新数据库，t2 在 t1 更新缓存前把数据库缓存都更新完了，t1 再更新缓存，这时候缓存上是 t1 的数据，数据库是 t2 的数据</p>
<ul>
<li><p>改进方式</p>
<p>若保证更新数据仅有少数的服务更新，可以将更新数据库请求入队处理，但是队列更新的引入增大了系统复杂度</p>
</li>
</ul>
<ol start="3">
<li><p>删除缓存 -&gt; 更新数据库</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610163854.png"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; Cache: delete data</span><br><span class="line"></span><br><span class="line">query1 -&gt; DB: select data</span><br><span class="line">query1 -&gt; Cache: insert data</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; DB: update result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li><p>可能出现的数据不一致</p>
<ol>
<li>如图所示，更新请求先删除缓存，查询请求从缓存获取不到数据从数据库获取数据（老数据）加载到缓存中，更新请求更新数据库</li>
<li>这样的流程会导致查询请求加载老数据到缓存中，后续更新请求更新新数据到数据库中，导致数据不一致</li>
</ol>
</li>
<li><p>改进方式</p>
<p>暂无。</p>
</li>
</ul>
<ol start="4">
<li>更新数据库 -&gt; 删除缓存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610163933.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">query1 -&gt; DB: select data</span><br><span class="line">transaction1 -&gt; DB: update result</span><br><span class="line">transaction1 -&gt; Cache: delete data</span><br><span class="line">query1 -&gt; Cache: insert data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li><p>可能出现的数据不一致</p>
<p>查询请求先拿到数据，在插入缓存前更新请求进来更新数据库并使缓存失效，这个请求比较罕见</p>
<ol>
<li>发生的场景<ol>
<li>查询请求所在机器请求缓存比更新请求做完的整个流程都要慢</li>
</ol>
</li>
<li>发生的概率<ol>
<li>很低。因为操作缓存一般会比操作数据库要快</li>
</ol>
</li>
</ol>
</li>
<li><p>改进方式</p>
<ol>
<li>变更数据记录变更事件<ol>
<li>步骤<ol>
<li>更新数据同步记录一个事件在本地内存中</li>
<li>查询请求在插入缓存前查询事件，如果存在变更则查数据库获取最新数据</li>
<li>如果此数据在查询请求插入缓存过程中一直变更，这里需要先返回当前数据库结果给上游，再开异步任务轮训事件&#x2F;数据库插入缓存</li>
</ol>
</li>
<li>适用场景<ol>
<li>只适用单节点</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="Server-维护缓存-amp-数据库的一致性"><a href="#Server-维护缓存-amp-数据库的一致性" class="headerlink" title="Server 维护缓存 &amp; 数据库的一致性"></a>Server 维护缓存 &amp; 数据库的一致性</h4><ol>
<li><p>Read though&#x2F;Write though</p>
<ul>
<li>read though</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610164000.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">query -&gt; repository: select data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: get data</span><br><span class="line">repository -&gt; DB: get data</span><br><span class="line">DB -&gt; repository: return data</span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line">repository -&gt; query: return data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li>wirte though</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610164021.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transcation -&gt; repository: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line">repository -&gt; DB: update data</span><br><span class="line">DB -&gt; repository: return result</span><br><span class="line">repository -&gt; transcation: return result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>可能出现的数据不一致<ul>
<li>程序没有优雅关闭，更新请求先更新了缓存，但还没更新数据库，数据丢失</li>
<li>更新缓存成功，更新数据库失败导致的数据不一致</li>
</ul>
</li>
<li>适用场景<ul>
<li>更新数据库极低概率失败</li>
<li>程序有优雅关闭功能</li>
</ul>
</li>
<li>改进方式<ul>
<li>暂无</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Write Behind</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610165345.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">query -&gt; repository: query data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: query data</span><br><span class="line">repository -&gt; DB: query data</span><br><span class="line">DB -&gt; repository: return data</span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; query: return data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610165405.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transcation -&gt; repository: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; DB: batch update data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li>可能出现的数据不一致<ul>
<li>程序没有优雅关闭，更新请求先更新了缓存，但还没更新数据库，数据丢失</li>
<li>批量更新数据库失败导致的数据不一致</li>
</ul>
</li>
<li>适用场景<ul>
<li>更新数据库极低概率失败</li>
<li>程序有优雅关闭功能</li>
</ul>
</li>
<li>改进方式<ul>
<li>暂无</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2023/04/30/message%20queue/kafka%20%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/message%20queue/kafka%20%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">kafka 不支持读写分离的原因</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 16:41:19" itemprop="dateCreated datePublished" datetime="2023-04-30T16:41:19+00:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前段时间在看 kafka 相关内容，发现 kafka “所有的”读写流量都在主 partition 上，从 partition 只负责备份数据。</p>
<blockquote>
<p>那么为什么 kafka 从 partition 不跟其他中间件一样承接读流量？</p>
</blockquote>
<h3 id="读写分离的初衷"><a href="#读写分离的初衷" class="headerlink" title="读写分离的初衷"></a>读写分离的初衷</h3><p>读写分离的初衷我觉得是利用读流量 &amp; 写流量不同的特性做针对性的优化，而这两种流量我觉得区别如下</p>
<table>
<thead>
<tr>
<th></th>
<th>读流量</th>
<th>写流量</th>
</tr>
</thead>
<tbody><tr>
<td>业务特性</td>
<td>展示类的业务</td>
<td>操作类业务</td>
</tr>
<tr>
<td>流量占比</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>可接受数据延迟</td>
<td>较大</td>
<td>非常小</td>
</tr>
<tr>
<td>增长的可预见性</td>
<td>高峰&#x2F;安全攻击可能会突发增长</td>
<td>总体平稳</td>
</tr>
</tbody></table>
<h3 id="使用-kafka-的业务特征"><a href="#使用-kafka-的业务特征" class="headerlink" title="使用 kafka 的业务特征"></a>使用 kafka 的业务特征</h3><ol>
<li>操作型业务，consumer 消费 producer 生产的消息，进行自身业务，这个消息就类似于 trigger</li>
<li>可支撑的流量较大，并且可支撑下游 consumer 较多，rebalance 需要一定的时间</li>
</ol>
<h3 id="kafka-架构"><a href="#kafka-架构" class="headerlink" title="kafka 架构"></a>kafka 架构</h3><ol>
<li>以 topic 为单位，一 topic 可拆分多个 partition，每个 partition 都可以有多个从 partition，不同 partition 分布在不同 broker 上</li>
<li>以 partition 为单位，形成 AR（Assigned Repllicas），ISR（In Sync Repllicas），OSR（Out Sync Repllicas），主 partition 接收到消息后按照 ack 策略同步到 ISR 中从 partition<ol>
<li>ack &#x3D; 0，producer 发出消息后就不管了</li>
<li>ack &#x3D; 1，producer 发出消息写入主 partition 所在 broker 的磁盘就算成功</li>
<li>ack &#x3D; all，producer 发出消息写入主 partition 以及 ISR 上所有副 partition 的磁盘才算成功</li>
</ol>
</li>
</ol>
<h3 id="kafka-没有主从读写分离的原因"><a href="#kafka-没有主从读写分离的原因" class="headerlink" title="kafka 没有主从读写分离的原因"></a>kafka 没有主从读写分离的原因</h3><ol>
<li>不能主从读写分离的原因<ol>
<li>kafka 承接的大多是操作型业务，这部分读操作对数据延迟非常敏感。</li>
<li>kafka 主从同步为半同步复制，并且有部分 partition 在 OSR 上，数据延迟较大</li>
<li>kafka 主 partition 接收到消息后，可以根据 ack 策略落盘，如果不是 all 的话存在数据丢失的风险</li>
</ol>
</li>
<li>不需要主从读写分离的原因<ol>
<li>kafka 本身就是多 partition 的架构，不同 parition 在不同的 broker 上，多主节点的结构本身分流了流量</li>
<li>kafka 本身就有成熟的 rebalance 机制，partition 上线与下线都比较无感</li>
</ol>
</li>
</ol>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2022/11/15/JAVA/%E5%AF%B9JVM-G1%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/JAVA/%E5%AF%B9JVM-G1%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">对JVM G1的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-15 00:24:02" itemprop="dateCreated datePublished" datetime="2022-11-15T00:24:02+00:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>NOTICE：本文仅记录本人对 JVM G1 的小小理解，没有详细记录每个点，若有误可指出</p>
</blockquote>
<h4 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h4><p>G1 将堆分为各个 region，大小通过 G1HeapRegionSize 指定</p>
<h5 id="region-分类"><a href="#region-分类" class="headerlink" title="region 分类"></a>region 分类</h5><h6 id="按-region-大小分"><a href="#按-region-大小分" class="headerlink" title="按 region 大小分"></a>按 region 大小分</h6><ol>
<li>普通 region，存放大小小于普通 refion 容量的一半的对象</li>
<li>humongous 区域，存放大对象</li>
</ol>
<h6 id="按功能来分"><a href="#按功能来分" class="headerlink" title="按功能来分"></a>按功能来分</h6><ol>
<li>新老代</li>
<li>老年代（humongous 只能在老年代）</li>
</ol>
<h4 id="新对象进入"><a href="#新对象进入" class="headerlink" title="新对象进入"></a>新对象进入</h4><ol>
<li>新对象根据大小进入普通 region &#x2F;humongous </li>
<li>记忆集维护<ol>
<li>本 region 维护一个记忆集，记忆集都是别的 region 对象指向本 region 的引用</li>
<li>写前屏障，处理 SATB，将修改前引用对象放入 SATB 队列</li>
<li>写后屏障，标记被修改的对象所在卡表为 dirty card</li>
</ol>
</li>
</ol>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="回收依据"><a href="#回收依据" class="headerlink" title="回收依据"></a>回收依据</h5><p>维护每个 region 中垃圾的价值（回收获得的空间大小以及所需时间的比值）大小，通过最大 GC 时间（-XX:MaxGCPauseMillis）优先处理价值大的 region</p>
<h5 id="回收分类"><a href="#回收分类" class="headerlink" title="回收分类"></a>回收分类</h5><ol>
<li>Young GC</li>
<li>Mixed GC（老年代中的内存比例超过IHOP）</li>
</ol>
<h5 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h5><ol>
<li>初始标记<ol>
<li>标记 GC Root 直接关联的对象</li>
<li>生成原始快照</li>
<li>修改 TAMS 的值</li>
<li>需要 Stop the world</li>
</ol>
</li>
<li>并发标记<ol>
<li>从 GC Root 开始进行可达性分析</li>
<li>处理 SATB 记录的引用变动的对象</li>
</ol>
</li>
<li>最终标记<ol>
<li>处于并发阶段遗留的少量 SATB 记录</li>
</ol>
</li>
<li>筛选回收<ol>
<li>计算各个 region 回收价值</li>
<li>回收<ol>
<li>将回收 region 中存活对象挪到空 region 中</li>
<li>清空原有 region</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="标记过程中问题处理"><a href="#标记过程中问题处理" class="headerlink" title="标记过程中问题处理"></a>标记过程中问题处理</h5><ol>
<li>在并发标记中，有新对象生成<ol>
<li>通过 TAMS 划分特定区域</li>
<li>新对象只能放在 TAMS 区域中，并且默认是黑色的</li>
</ol>
</li>
<li>在并发标记进行可达性分析，引用变动的对象处理<ol>
<li>使用 SATB 记录灰色到白色删除的引用</li>
<li>在最终标记以灰色的对象为根，重新扫描一次</li>
</ol>
</li>
</ol>
<h5 id="停顿分析"><a href="#停顿分析" class="headerlink" title="停顿分析"></a>停顿分析</h5><ol>
<li>初始标记是 STW 的，但是只标记 GC Root，所以停顿时间较短</li>
<li>并发标记因为是与应用线程并发进行的，所以即使需要进行可达性分析，但是也不会停顿</li>
<li>最终标记，因为并发标记漏的对象比较少，所以即使 STW，停顿也不长</li>
<li>筛选回收，因为 G1 实际是用的是复制算法，复制对象时间可能较长，所以耗时较多是在此阶段</li>
</ol>
<h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><ol>
<li>黑色意义为被访问过的对象，引用都扫描过，并且确认最后是存活的，GC Root 默认为黑色</li>
<li>灰色意义为被访问过的对象，有一个引用未被扫描过，未确定是否存活</li>
<li>白色意义为未被访问过的对象</li>
</ol>
<h5 id="对并发标记中对象引用变化处理"><a href="#对并发标记中对象引用变化处理" class="headerlink" title="对并发标记中对象引用变化处理"></a>对并发标记中对象引用变化处理</h5><h6 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h6><ol>
<li>全称为 Snapshot At The Beginning</li>
<li>Region 包含 5 个指针<ol>
<li>bottom</li>
<li>previous TAMS</li>
<li>next TAMS</li>
<li>top</li>
<li>end</li>
</ol>
</li>
<li>作用流程<ol>
<li>并发标记中，新创建的对象在 next TAMS -&gt; top 之间，此区间默认为黑色，默认存活</li>
<li>灰色对象删除指向白色的引用，记录下来</li>
<li>以记录下来的灰色为根，重新扫描</li>
</ol>
</li>
</ol>
<h6 id="Incremental-Update"><a href="#Incremental-Update" class="headerlink" title="Incremental Update"></a>Incremental Update</h6><ol>
<li>黑色插入新的指向白色的引用，记录下来</li>
<li>并发扫描结束后，以记录下来的黑色为根，重新扫描一遍</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15072811/4679940">https://blog.51cto.com/u_15072811/4679940</a></p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2022/06/06/cache/%E7%BC%93%E5%86%B2%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/06/cache/%E7%BC%93%E5%86%B2%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5/" class="post-title-link" itemprop="url">缓冲更新策略</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-06 22:34:32" itemprop="dateCreated datePublished" datetime="2022-06-06T22:34:32+00:00">2022-06-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-06-28 02:50:14" itemprop="dateModified" datetime="2025-06-28T02:50:14+00:00">2025-06-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>近段时间在学习缓存相关知识的时候，看到了缓存更新策略，于是就根据自己的理解，写下这篇文章</p>
<h5 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h5><ul>
<li>Cache Aside</li>
<li>Read &#x2F; Write Though</li>
<li>Write Behind</li>
</ul>
<h5 id="Cache-Aside"><a href="#Cache-Aside" class="headerlink" title="Cache Aside"></a>Cache Aside</h5><ol>
<li><p>步骤</p>
<ol>
<li>读请求未命中缓存，取数据库数据，并回写缓存</li>
<li>写请求先更新数据库，再让缓存失效</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>实现简单，调用者可控制数据持久化的细节</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>上层需要同时管理缓存与持久化，调用较复杂</li>
<li>写请求与读请求并发，读请求持续时间比写请求长，可能会覆盖旧数据到缓存中</li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li>允许缓存数据不准确的场景</li>
<li>因为并发情况下，可能造成脏数据的情况，所以 QPS 较低场景也可以适用</li>
</ol>
</li>
<li><p>代码示例</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheAside</span>&lt;T, K&gt; <span class="keyword">implements</span> <span class="title class_">CacheUpdate</span>&lt;T, K&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, T&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="comment">//if cache has data, return</span></span><br><span class="line">        <span class="keyword">return</span> map.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        map.remove(key, data);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.nonNull(map.put(key, data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheAside</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>调用示例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CacheAsideClient</span>&lt;T, K&gt; <span class="keyword">implements</span> <span class="title class_">CacheUpdateClient</span>&lt;T, K&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> CacheUpdateFactory&lt;T, K&gt; factory = CacheUpdateFactory.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CacheUpdate&lt;T, K&gt; cacheUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DatabaseOperation&lt;T, K&gt; databaseOperation;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">(K key)</span>&#123;</span><br><span class="line">        <span class="comment">//get data from cache</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">dataFromCache</span> <span class="operator">=</span> cacheUpdate.getData(key);</span><br><span class="line">        <span class="comment">//if cache haven&#x27;t, get from database and put to cache</span></span><br><span class="line">        <span class="keyword">if</span>(Objects.nonNull(dataFromCache))&#123;</span><br><span class="line">            <span class="keyword">return</span> dataFromCache;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">dataFromDatabase</span> <span class="operator">=</span> databaseOperation.getData(key);</span><br><span class="line">        cacheUpdate.addData(key, dataFromDatabase);</span><br><span class="line">        <span class="keyword">return</span> dataFromDatabase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(K key, T data)</span>&#123;</span><br><span class="line">        <span class="comment">//update data to database</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">updateToDatabaseRes</span> <span class="operator">=</span> databaseOperation.updateData(key, data);</span><br><span class="line">        <span class="keyword">if</span>(updateToDatabaseRes)&#123;</span><br><span class="line">            <span class="comment">//invalid cache data</span></span><br><span class="line">            <span class="keyword">return</span> cacheUpdate.removeData(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addData</span><span class="params">(K key, T data)</span>&#123;</span><br><span class="line">        <span class="comment">//add data to database</span></span><br><span class="line">        <span class="keyword">return</span> databaseOperation.addData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeData</span><span class="params">(K key)</span>&#123;</span><br><span class="line">        <span class="comment">//remove from database</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">removeFromDatabaseRes</span> <span class="operator">=</span> databaseOperation.removeData(key);</span><br><span class="line">        <span class="keyword">if</span>(removeFromDatabaseRes)&#123;</span><br><span class="line">            <span class="comment">//invalid cache data</span></span><br><span class="line">            <span class="keyword">return</span> cacheUpdate.removeData(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CacheAsideClient</span><span class="params">()</span> &#123;</span><br><span class="line">        cacheUpdate = factory.getObject(CacheUpdateEnum.CACHE_ASIDE);</span><br><span class="line">        databaseOperation = (DatabaseOperation&lt;T, K&gt;) <span class="keyword">new</span> <span class="title class_">MockDatabaseOperation</span>&lt;T&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Read-x2F-Write-Though"><a href="#Read-x2F-Write-Though" class="headerlink" title="Read &#x2F; Write Though"></a>Read &#x2F; Write Though</h5><ol>
<li><p>步骤</p>
<ol>
<li>读&#x2F;写请求都只依赖缓存</li>
<li>缓存数据同步持久化</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>上层对数据是否持久化&#x2F;持久化实现无感</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>同步持久化性能较低，但能有效保证数据一致性</li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li>性能要求不高的场景</li>
</ol>
</li>
<li><p>代码示例</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOrWriteThough</span>&lt;T, K&gt; <span class="keyword">implements</span> <span class="title class_">CacheUpdate</span>&lt;T, K&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DatabaseOperation&lt;T, K&gt; databaseOperation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, T&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="comment">//if cache has data, return</span></span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//get data from database and write to cache</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> databaseOperation.getData(key);</span><br><span class="line">        map.put(key, data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        map.put(key, data);</span><br><span class="line">        <span class="keyword">return</span> databaseOperation.updateData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        map.put(key, data);</span><br><span class="line">        <span class="keyword">return</span> databaseOperation.addData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">        <span class="keyword">return</span> databaseOperation.removeData(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadOrWriteThough</span><span class="params">()</span> &#123;</span><br><span class="line">        databaseOperation = (DatabaseOperation&lt;T, K&gt;) <span class="keyword">new</span> <span class="title class_">MockDatabaseOperation</span>&lt;&gt;();</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>调用示例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReadOrWriteThoughClient</span>&lt;T, K&gt; <span class="keyword">implements</span> <span class="title class_">CacheUpdateClient</span>&lt;T, K&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CacheUpdateFactory&lt;T, K&gt; factory = CacheUpdateFactory.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CacheUpdate&lt;T, K&gt; cacheUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.getData(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.updateData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.addData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.removeData(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ReadOrWriteThoughClient</span><span class="params">()</span> &#123;</span><br><span class="line">        cacheUpdate = factory.getObject(CacheUpdateEnum.READ_WRITE_THOUGH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="Write-Behind"><a href="#Write-Behind" class="headerlink" title="Write Behind"></a>Write Behind</h5><ol>
<li><p>步骤</p>
<ol>
<li>读&#x2F;写请求都只依赖缓存</li>
<li>缓存数据异步批量持久化</li>
</ol>
</li>
<li><p>优点</p>
<ol>
<li>上层对数据是否持久化&#x2F;持久化实现无感</li>
<li>异步持久化，性能较 Read &#x2F;Write Though 提高</li>
</ol>
</li>
<li><p>缺点</p>
<ol>
<li>异步持久化可能会导致数据丢失</li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li>性能要求较高的场景</li>
<li>允许持久化数据丢失场景</li>
</ol>
</li>
<li><p>代码示例</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteBehind</span>&lt;T, K&gt; <span class="keyword">implements</span> <span class="title class_">CacheUpdate</span>&lt;T, K&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;K, T&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DatabaseOperation&lt;T, K&gt; databaseOperation;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadPoolExecutor threadPoolExecutor;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">T</span> <span class="variable">data</span> <span class="operator">=</span> databaseOperation.getData(key);</span><br><span class="line">        map.put(key, data);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        map.put(key, data);</span><br><span class="line">        threadPoolExecutor.execute(() -&gt; databaseOperation.updateData(key, data));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        map.put(key, data);</span><br><span class="line">        threadPoolExecutor.execute(() -&gt; databaseOperation.addData(key, data));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        map.remove(key);</span><br><span class="line">        threadPoolExecutor.execute(() -&gt; databaseOperation.removeData(key));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteBehind</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        databaseOperation = (DatabaseOperation&lt;T, K&gt;) <span class="keyword">new</span> <span class="title class_">MockDatabaseOperation</span>&lt;&gt;();</span><br><span class="line">        threadPoolExecutor = <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">5</span>, <span class="number">10</span>, <span class="number">1000</span>, TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">1000</span>), <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>调用示例</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteBehindClient</span>&lt;T, K&gt; <span class="keyword">implements</span> <span class="title class_">CacheUpdateClient</span>&lt;T, K&gt;&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CacheUpdateFactory&lt;T, K&gt; cacheUpdateFactory = CacheUpdateFactory.getInstance();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CacheUpdate&lt;T, K&gt; cacheUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.getData(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">updateData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.updateData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addData</span><span class="params">(K key, T data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.addData(key, data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">removeData</span><span class="params">(K key)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheUpdate.removeData(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">WriteBehindClient</span><span class="params">()</span> &#123;</span><br><span class="line">        cacheUpdate = cacheUpdateFactory.getObject(CacheUpdateEnum.WRITE_BEHIND);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><table>
<thead>
<tr>
<th>分类</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Cache Aside</td>
<td>1. 实现简单，调用者可控制数据持久化的细节</td>
<td>1. 写请求与读请求并发，读请求持续时间比写请求长，可能会覆盖旧数据到缓存中<br />2. 上层需要同时管理缓存与持久化，调用较复杂</td>
<td>1. 允许缓存数据不准确的场景<br />2. 因为并发情况下，可能造成脏数据的情况，所以 QPS 较低场景也可以适用</td>
</tr>
<tr>
<td>Read &#x2F; Write Though</td>
<td>1. 上层对数据是否持久化&#x2F;持久化实现无感</td>
<td>1. 同步持久化性能较低，但能有效保证数据一致性</td>
<td>1. 性能要求不高的场景</td>
</tr>
<tr>
<td>Write Behind</td>
<td>1. 上层对数据是否持久化&#x2F;持久化实现无感<br />2. 异步持久化，性能较 Read &#x2F;Write Though 提高</td>
<td>1. 异步持久化可能会导致数据丢失</td>
<td>1. 性能要求较高的场景<br />2. 允许持久化数据丢失场景</td>
</tr>
</tbody></table>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cartoon Yu</p>
  <div class="site-description" itemprop="description">do what I like, love who I love</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cartoonYu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cartoonYu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cartoonyu3@gmail.com" title="E-Mail → mailto:cartoonyu3@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cartoon_?spm=1010.2135.3001.5421" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;cartoon_?spm&#x3D;1010.2135.3001.5421" rel="noopener" target="_blank"><i class=" fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/cartoon_5cce2e0fb8fae" title="Segmentfault → https:&#x2F;&#x2F;segmentfault.com&#x2F;u&#x2F;cartoon_5cce2e0fb8fae" rel="noopener" target="_blank"><i class=" fa-fw"></i>Segmentfault</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/theme-next/hexo-theme-next" title="https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next" rel="noopener" target="_blank">Link1</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/Fosu_Chenai/article/details/111155327" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Fosu_Chenai&#x2F;article&#x2F;details&#x2F;111155327" rel="noopener" target="_blank">Link2</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zhuanlan.zhihu.com/p/351031589" title="https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;351031589" rel="noopener" target="_blank">Link3</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cartoon Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
