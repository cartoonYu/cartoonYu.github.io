<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"cartoonyu.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"default","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="do what I like, love who I love">
<meta property="og:type" content="website">
<meta property="og:title" content="cartoon&#39;s blog">
<meta property="og:url" content="https://cartoonyu.github.io/index.html">
<meta property="og:site_name" content="cartoon&#39;s blog">
<meta property="og:description" content="do what I like, love who I love">
<meta property="og:locale">
<meta property="article:author" content="cartoon Yu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://cartoonyu.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>cartoon's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">cartoon's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/07/14/JAVA/%E5%AF%B9%20JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/07/14/JAVA/%E5%AF%B9%20JVM%20%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">对 JVM 垃圾收集器的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-07-14 00:37:35" itemprop="dateCreated datePublished" datetime="2025-07-14T00:37:35+00:00">2025-07-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究 JVM 相关的知识点，对垃圾收集器有一些自己的看法，所以就记录下来。</p>
<h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>顾名思义，垃圾收集器就是清理程序运行过程中产生的垃圾，防止对象膨胀导致应用程序 OOM。</p>
<p>而垃圾指的是当前时刻下程序不再需要使用的对象，即不可达对象。</p>
<h3 id="作用过程"><a href="#作用过程" class="headerlink" title="作用过程"></a>作用过程</h3><p>根据定义，垃圾收集器过程分为两大步：识别垃圾（不可达对象），清理不可达对象。</p>
<h4 id="识别不可达对象"><a href="#识别不可达对象" class="headerlink" title="识别不可达对象"></a>识别不可达对象</h4><p>不可达对象的定义：程序中其他对象对该对象的引用次数为 0。这衍生出两种识别方式：引用计数法，可达性分析。</p>
<table>
<thead>
<tr>
<th></th>
<th>引用计数法</th>
<th>可达性分析</th>
</tr>
</thead>
<tbody><tr>
<td>作用原理</td>
<td>每个对象都维护一个计数器，其他对象有引用的话，计数器加一</td>
<td>对象的引用关系为树状结构，根节点为 JVM 指定的 GC Root。通过深度优先遍历搜索存活对象</td>
</tr>
<tr>
<td>优点</td>
<td>使用简单。无额外存储成本。计数器可维护在对象头上。</td>
<td>对象图清晰，不存在无法清理的垃圾</td>
</tr>
<tr>
<td>缺点</td>
<td>存在无法清理的垃圾。例子：两个互相引用的对象，没有被其他对象引用，实际上是垃圾，但是仍被识别成存活对象</td>
<td>使用比较复杂，需要额外内存空间存储对象关系</td>
</tr>
</tbody></table>
<h4 id="清理不可达对象"><a href="#清理不可达对象" class="headerlink" title="清理不可达对象"></a>清理不可达对象</h4><p>清理不可达对象主要有三种方式：标记 - 清除算法，复制算法，标记 - 整理算法。</p>
<table>
<thead>
<tr>
<th></th>
<th>标记 - 清除</th>
<th>复制</th>
<th>标记 - 整理</th>
</tr>
</thead>
<tbody><tr>
<td>作用原理</td>
<td>直接清除不可达对象占用的内存空间</td>
<td>内存分为两块区域：当前区&#x2F;空闲区。将存活对象复制到空闲区中，清理当前区</td>
<td>清除不可达对象占用的内存空间，移动存活对象到内存一端，移动分配指针到末尾</td>
</tr>
<tr>
<td>优点</td>
<td>实现简单</td>
<td>实现简单</td>
<td>不会产生内存碎片。不需对内存进行分区，内存利用率高</td>
</tr>
<tr>
<td>缺点</td>
<td>会造成内存碎片</td>
<td>内存利用率低。涉及内存仅有一半可用</td>
<td>实现比较复杂</td>
</tr>
<tr>
<td>适用场景</td>
<td>少量垃圾的清理</td>
<td>大量垃圾的清理</td>
<td>少量垃圾的清理</td>
</tr>
</tbody></table>
<h3 id="垃圾收集器种类"><a href="#垃圾收集器种类" class="headerlink" title="垃圾收集器种类"></a>垃圾收集器种类</h3><p>种类太多了，仅列以下几种：</p>
<ul>
<li>专注于老年代的 CMS </li>
<li>局部收集的 G1 </li>
<li>低延迟的 Shenandoah、ZGC</li>
</ul>
<h2 id="垃圾收集器的发展历程"><a href="#垃圾收集器的发展历程" class="headerlink" title="垃圾收集器的发展历程"></a>垃圾收集器的发展历程</h2><h3 id="分代回收的-JVM"><a href="#分代回收的-JVM" class="headerlink" title="分代回收的 JVM"></a>分代回收的 JVM</h3><p>在 G1 出现之前，JVM 内存区域主要分为两部份：新生代&#x2F;老年代。新生代的收集器大多采用复制算法，老年代的则是采用标记 - 清除算法。</p>
<p>老年代的 CMS 收集器作用过程如下</p>
<ol>
<li>初始标记（STW 确定 GC Roots）</li>
<li>并发标记（与用户线程并行扫描对象图，三色标记法采用增量更新法）</li>
<li>重新标记（STW 最终确定对象图）</li>
<li>并发清除（与用户线程并行，采用标记 - 清除算法清除所有不可达对象）</li>
</ol>
<p>而这样的内存分配与回收过程我认为存在几个缺点：</p>
<ol>
<li>内存分配不合理。区分新生代&#x2F;老年代，导致总体利用率不高。</li>
<li>新生代内存利用率低。虽然依据对象朝生夕灭的特性采用复制算法，提升垃圾回收的效率，但是降低了新生代整体的内存利用率。</li>
<li>老年代存在空间碎片。虽然依据对象存活几率大的特性采用标记 - 清除算法，提升垃圾回收的效率，但是产生的内存碎片后续只能通过 FULL GC 解决。</li>
<li>回收时间不可控。在 CMS 并发清除过程中清除了所有不可达对象，时间未知。且回收线程与用户线程并行，也会占用一部份系统资源。</li>
</ol>
<h3 id="可预测回收时间的-G1"><a href="#可预测回收时间的-G1" class="headerlink" title="可预测回收时间的 G1"></a>可预测回收时间的 G1</h3><p>G1 部分解决了上面说的缺点</p>
<ol>
<li>针对内存分配不合理。G1 将内存分为普通 Region&#x2F;Humongous region，宏观上没有连续的新生代&#x2F;老年代。</li>
<li>针对新生代利用率低。G1 收集垃圾微观上采用复制算法，宏观上采用标记 - 整理算法，辅以 Region 的内存布局，无需大的空闲区。</li>
<li>针对空间碎片。从微观&#x2F;宏观的垃圾收集算法都避免了内存碎片的产生。</li>
<li>针对回收时间不可控。G1 不再回收所有对象，而是在设定的回收时间内回收高价值的 Region。</li>
</ol>
<p>G1 的作用过程如下</p>
<ol>
<li><p>初始标记（STW 确定 GC Roots）</p>
</li>
<li><p>并发标记（与用户线程并行扫描对象图，三色标记法采用原始快照法）</p>
</li>
<li><p>最终标记（STW 最终确定对象图）</p>
</li>
<li><p>筛选回收（微观上采用复制算法，宏观上采用标记 - 整理算法在指定时间内回收的高价值 Region）</p>
</li>
</ol>
<h4 id="两个关键问题"><a href="#两个关键问题" class="headerlink" title="两个关键问题"></a>两个关键问题</h4><ul>
<li>G1 为什么三色标记法的解决采用原始快照法</li>
</ul>
<p>对象关系采用记忆集维护减少了对象扫描时间，同时减少浮动垃圾带来的筛选回收成本。</p>
<p>在<a href="https://cartoonyu.github.io/2025/06/28/JAVA/%E5%AF%B9%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/">三色标记法文章</a>中，对比了增量更新与原始快照的优点缺点：</p>
<ol>
<li><p>增量更新的优点是扫描范围小，缺点是会产生浮动垃圾。</p>
</li>
<li><p>原始更新的优点是不会产生浮动垃圾，缺点是扫描了整个对象图。</p>
</li>
</ol>
<p>G1 是一个基于 Region 的收集器，使用记忆集管理对象关系，减少了最终标记的时间。同时微观上采用复制算法，浮动垃圾的产生会增加复制工作量。所以采用原始快照的方式。</p>
<ul>
<li>为什么筛选回收时微观上采用复制算法</li>
</ul>
<p>复制存活对象的范围变小。G1 的复制是基于 Region 的，Region 所占整体内存比例较小，有效避免了复制算法的缺点。</p>
<h4 id="G1-仍存在的问题"><a href="#G1-仍存在的问题" class="headerlink" title="G1 仍存在的问题"></a>G1 仍存在的问题</h4><ol>
<li>对象堆越大停顿时间越长。G1 需要 STW 进行筛选回收，主要涉及存活对象移动与记忆集指针修改。回收的对象越多停顿时间越长，不然只能等 FULL GC。</li>
<li>极端情况下需要一半的 Region 作为空闲区。虽然对象朝生夕灭，但极端情况下所有对象都存活就激发了复制算法的弊端。</li>
</ol>
<h3 id="低延迟的-Shenandoah"><a href="#低延迟的-Shenandoah" class="headerlink" title="低延迟的 Shenandoah"></a>低延迟的 Shenandoah</h3><h4 id="作用过程-1"><a href="#作用过程-1" class="headerlink" title="作用过程"></a>作用过程</h4><ol>
<li><p>初始标记（STW 确定 GC Roots）</p>
</li>
<li><p>并发标记（与用户线程并行扫描对象图，三色标记法采用原始快照法）</p>
</li>
<li><p>最终标记（STW 最终确定对象图）</p>
</li>
<li><p>筛选回收</p>
<ol>
<li>并发清理</li>
<li>并发回收</li>
<li>初始引用更新</li>
<li>并发引用更新</li>
<li>最终引用更新</li>
<li>并发清理</li>
</ol>
</li>
</ol>
<h4 id="G1-存在问题的解法"><a href="#G1-存在问题的解法" class="headerlink" title="G1 存在问题的解法"></a>G1 存在问题的解法</h4><p>针对 G1 存在的问题 1: 对象堆越大停顿时间越长，Shenandoah 给出了它的解法：二八定律。</p>
<p>Shenandoah 将需回收的 Region 分为两部分：无存活对象的 Region（大多数），存在存活对象的 Region（少数）。</p>
<ul>
<li>无存活对象的 Region，不需要有其他记忆集的修改，在并发清理阶段直接清理。</li>
<li>存在存活对象的 Region，在并发回收阶段复制对象后维护一个转发指针，在并发引用更新与最终引用更新再修正引用。</li>
</ul>
<h4 id="低延迟的体现"><a href="#低延迟的体现" class="headerlink" title="低延迟的体现"></a>低延迟的体现</h4><p>将 STW 复制清理对象简便为 STW 更新对象指针，使应用程序感知停顿时间短。</p>
<h4 id="Shenandoah-仍存在的问题"><a href="#Shenandoah-仍存在的问题" class="headerlink" title="Shenandoah 仍存在的问题"></a>Shenandoah 仍存在的问题</h4><ol>
<li>极端情况下需要一半的 Region 作为空闲区。因为 Shenandoah 在 4.2 中复制了所有存活对象到新 Region，仍存在与 G1 一样的问题。</li>
<li>转发指针降低了对象访问的性能。Shenandoah 在 4.2 建立了转发指针，每次访问存活对象都需要通过读屏障，降低了访问性能。</li>
</ol>
<h3 id="低延迟的-ZGC"><a href="#低延迟的-ZGC" class="headerlink" title="低延迟的 ZGC"></a>低延迟的 ZGC</h3><h4 id="作用过程-2"><a href="#作用过程-2" class="headerlink" title="作用过程"></a>作用过程</h4><ol>
<li>并发标记。基于染色指针存储对象图信息。</li>
<li>并发预备重分配。选择待复制的存活对象所在的 Region 集。</li>
<li>并发重分配。将重分配的存活对象复制到新的 Region，并维护转发关系表。</li>
<li>并发重映射。按照转发关系表修正对象指针的指向。</li>
</ol>
<h4 id="G1-存在问题的解法-1"><a href="#G1-存在问题的解法-1" class="headerlink" title="G1 存在问题的解法"></a>G1 存在问题的解法</h4><ul>
<li>问题 1 的解法</li>
</ul>
<p>与 G1 需要 STW 移动对象与修改引用不同，ZGC 采用并发移动对象与维护转发关系表的方式避免了 STW。</p>
<ul>
<li>问题 2 的解法</li>
</ul>
<p>与 G1 一次性复制存活对象不同，ZGC 采用渐进式“假”清理以及方式清理避免。</p>
<p>渐进式“假”清理的含义：</p>
<ol>
<li>渐进式：ZGC 不会一次性复制空对象，而是逐渐将存活对象复制到空 Region。</li>
<li>假清理： 当复制完成后，当前 Region 即标为空闲并可被后续存活对象的复制使用。当访问存活对象时，自动将旧地址刷新为转发关系表中的新地址。</li>
</ol>
<p>放弃清理的含义：当所有对象存活，ZGC 放弃后续的复制回收过程。</p>
<h4 id="低延迟的体现-1"><a href="#低延迟的体现-1" class="headerlink" title="低延迟的体现"></a>低延迟的体现</h4><p>ZGC 渐进式完成之前需要 STW 做的内存分配、指针修正，将串行变成并行，使应用程序感知延迟低。</p>
<p>但是 ZGC 也有 STW 的步骤，只与 GC Root 的数量有关：</p>
<ol>
<li>并发标记前的 GC Root 确定</li>
<li>并发标记后的遗漏引用的处理</li>
<li>并发重分配开始前的 GC Root 新地址的计算</li>
</ol>
<h4 id="ZGC-仍存在的问题"><a href="#ZGC-仍存在的问题" class="headerlink" title="ZGC 仍存在的问题"></a>ZGC 仍存在的问题</h4><ol>
<li>新对象分配速率不能太快。因为 ZGC 为渐进式清理，垃圾回收与新对象分配并发进行，所以新对象分配速率不能高于垃圾回收的速率。否则会触发频繁的 STW 用户线程以及堆空间扩容，甚至恶化到全局的 FULL GC。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>纵览垃圾收集器的发展史，我觉得就是小步快跑解决存在的问题。</p>
<h3 id="阶段-1-–-分代的内存布局"><a href="#阶段-1-–-分代的内存布局" class="headerlink" title="阶段 1 – 分代的内存布局"></a>阶段 1 – 分代的内存布局</h3><p>因为 Java 对象的“二八定律”：多数对象朝生夕灭，少数对象一直存活，所以内存布局一开始就分为新生代&#x2F;老年代。</p>
<p>复制算法能简单的清理多数对象，标记清理算法能简单的清理少数对象，所以成为了新生代&#x2F;老年代的回收算法。</p>
<h3 id="内存布局对比"><a href="#内存布局对比" class="headerlink" title="内存布局对比"></a>内存布局对比</h3><table>
<thead>
<tr>
<th></th>
<th>分代的内存布局</th>
<th>基于 Region 的内存布局</th>
</tr>
</thead>
<tbody><tr>
<td>优点</td>
<td>对象引用关系简单</td>
<td>内存整体利用率低，垃圾收集时间可预知甚至低延迟</td>
</tr>
<tr>
<td>缺点</td>
<td>内存整体利用率低，垃圾收集时间不可预知</td>
<td>对象引用关系复杂</td>
</tr>
<tr>
<td>适用的垃圾收集器</td>
<td>CMS、ParNew、Serial 等</td>
<td>G1、Shenandoah、ZGC</td>
</tr>
</tbody></table>
<h3 id="阶段-2-–-G1-垃圾收集器"><a href="#阶段-2-–-G1-垃圾收集器" class="headerlink" title="阶段 2 – G1 垃圾收集器"></a>阶段 2 – G1 垃圾收集器</h3><p>随着 Java 应用对象个数膨胀，提升内存利用率与降低程序对垃圾收集的感知也成为了需解决的任务。</p>
<p>在提升内存利用率方面，内存布局从分代的几大块演变成几千块的小 Region，不再区分新生代&#x2F;老年代。采用宏观上标记 - 整理算法减少内存碎片并提升利用率。在降低 STW 时间方面，G1 不再回收所有垃圾，只在特定时间内回收高价值的 Region。</p>
<h3 id="阶段-3-–-低延迟垃圾收集器"><a href="#阶段-3-–-低延迟垃圾收集器" class="headerlink" title="阶段 3 – 低延迟垃圾收集器"></a>阶段 3 – 低延迟垃圾收集器</h3><p>G1 虽然是划时代的创新，但是也存在两个问题：</p>
<ol>
<li>极端情况下仍需要一半空闲 Region </li>
<li>对象堆越大停顿时间越长</li>
</ol>
<p>Shenandoah 通过将 STW 清理对象转变为 STW 重置对象指针解决了问题 2，但遗留问题 1 尚未解决。</p>
<p>ZGC 则通过将 STW 清理对象转变为 STW 重置对象指针同时解决了两个问题，但造成新的问题：新对象分配速率不允许快于垃圾收集速率。</p>
<h3 id="阶段-4-–-待解决的问题"><a href="#阶段-4-–-待解决的问题" class="headerlink" title="阶段 4 – 待解决的问题"></a>阶段 4 – 待解决的问题</h3><p> 针对 ZGC 的新问题，ZGC 暂时通过提升收集速率与扩容堆解决。</p>
<p>但是 ZGC 的解法只是缓兵之计，收集速率的提升会导致程序分配的资源减少，堆的大小受物理内存的限制。</p>
<p>但是 ZGC 最大支持 T 级别内存，配套的 CPU 也不会差，上面的极端情况比较难出现，就出现了再说吧。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/06/28/JAVA/%E5%AF%B9%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/28/JAVA/%E5%AF%B9%E4%B8%89%E8%89%B2%E6%A0%87%E8%AE%B0%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">对三色标记法的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-28 10:46:00" itemprop="dateCreated datePublished" datetime="2025-06-28T10:46:00+00:00">2025-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在回看 JVM 的相关概念，看到了三色标记法的使用，所以就记录一下。</p>
<h2 id="三色标记法是什么"><a href="#三色标记法是什么" class="headerlink" title="三色标记法是什么"></a>三色标记法是什么</h2><p>在可达性分析的过程中，对象有且只有三种状态：完全没被扫描，对象被扫描但子对象还没完全被扫描，对象与其子对象都被扫描了。</p>
<p>而这三种状态即为三种颜色</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">白色：完全没被扫描。对象与子对象确定被回收。</span><br><span class="line">灰色：对象被扫描但子对象还没完全被扫描。根对象确定存活，子对象可能被回收。</span><br><span class="line">黑色：对象与其子对象都被扫描了。对象与子对象确定存活。</span><br></pre></td></tr></table></figure>



<h2 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h2><p>三色标记法是对堆上的对象进行归类，简化可达性分析中的重复扫描的工作量。</p>
<h2 id="作用阶段"><a href="#作用阶段" class="headerlink" title="作用阶段"></a>作用阶段</h2><p>作用阶段包括初始标记与并发标记。</p>
<p>初始标记主要是确定 GC Root ，并把根节点标为灰色。初始标记需要暂停用户线程。</p>
<p>并发标记主要是根据 GC Root 往下扫描子对象，将子对象从白色扭转为黑色&#x2F;灰色。并发标记过程标记线程与用户线程并行。</p>
<h2 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h2><p>在进行回收前，对象有且只会存在两个颜色：黑色以及白色。<br>但由于扫描所有对象耗时久，所以扫描只能与用户线程并发，并发过程中会发生对象图关系的改变，会出现两个问题</p>
<ol>
<li>黑色对象变成了白色对象，最终应该被回收但未被回收，俗称浮动垃圾，下一次回收也行。</li>
<li>白色对象变成了黑色对象，最终不应被回收却被回收了，会导致程序异常。</li>
</ol>
<h2 id="问题的原因"><a href="#问题的原因" class="headerlink" title="问题的原因"></a>问题的原因</h2><p>白色对象变成黑色对象的原因，需要同时满足下面两个：</p>
<ol>
<li>黑色根对象增加了对上述白色对象的引用。</li>
<li>灰色根对象删除对白色子对象引用。</li>
</ol>
<p>最后的结果是：白色对象实际上是黑色对象，但回收程序仍认为是白色对象。</p>
<h2 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h2><p>针对上述的变动，解决办法有两个：</p>
<ol>
<li>增量更新：记录黑色根对象对白色对象的新增调用，并且以黑色根对象为根重新扫描这部分的引用。</li>
<li>原始快照：记录灰色根对象删除对白色子对象的删除，并且重新扫描整个对象图。</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="left">增量更新</th>
<th align="left">原始快照</th>
</tr>
</thead>
<tbody><tr>
<td align="center">优点</td>
<td align="left">扫描范围小，最终标记过程停顿时间短</td>
<td align="left">不会产生浮动垃圾，根据对象图重新扫描</td>
</tr>
<tr>
<td align="center">缺点</td>
<td align="left">产生新的浮动垃圾。仅记录新增引用，未记录删除引用</td>
<td align="left">最终标记时间长。扫描了整个对象图</td>
</tr>
<tr>
<td align="center">适用范围</td>
<td align="left">老年代。老年代对象引用变化少，上述缺点出现概率低</td>
<td align="left">基于 Region 实现的垃圾收集器</td>
</tr>
</tbody></table>
<h2 id="最后的叨叨"><a href="#最后的叨叨" class="headerlink" title="最后的叨叨"></a>最后的叨叨</h2><blockquote>
<p> 为什么会有并发标记与最终标记两阶段</p>
</blockquote>
<p>我觉得主要是为了尽可能缩短 STW 的时间。</p>
<p>两阶段更像是二八原则的具象化。80%对象关系不会变化，20%对象关系会变化（实际上更少）。</p>
<p>针对不会变化的部分，并发标记能减少业务感知的时间。针对变化的部分，则记录下来再 STW 确定最终引用关系。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/06/01/JAVA/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/06/01/JAVA/%E5%B9%B6%E5%8F%91%E6%9B%B4%E6%96%B0%E5%8F%98%E9%87%8F%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">并发更新变量的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-06-01 16:39:09" itemprop="dateCreated datePublished" datetime="2025-06-01T16:39:09+00:00">2025-06-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近遇到一个很有意思的问题，如下代码在多线程运行下的问题与解决方案</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Counter &#123;</span><br><span class="line">    private static int count = 0;</span><br><span class="line">    </span><br><span class="line">    public static void increment() &#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static int getCount() &#123;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="变量累加的过程"><a href="#变量累加的过程" class="headerlink" title="变量累加的过程"></a>变量累加的过程</h2><p>由 Java 的内存模型可知，变量的累加经历三个阶段：从主内存读取到工作内存 -&gt; 工作内存中修改 -&gt; 写回主内存</p>
<h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p>由上述三步可知，可能存在问题有三个：</p>
<ol>
<li>读取的值是否为当前时刻的最新值</li>
<li>累加的前提值是否为当前时刻的最新值</li>
<li>写回主内存是否为当前时刻期望值</li>
</ol>
<p>问题 1 ，一定是。因为变量存在于内存某一块区域，任何时刻的读取都是对该内存的读取。</p>
<p>问题 2，不一定是。经历了复制到工作内存的阶段，工作内存和主内存的值不能保证强一致。</p>
<p>问题 3，不一定是。因为累加的前提值不准确以及多线程同时写回的顺序问题，所以修改后的值与期望值可能不一致。</p>
<p>所以问题的关键是：如何保证工作内存读取的是最新值，如何保证写回主内存是顺序的。</p>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><h3 id="本地"><a href="#本地" class="headerlink" title="本地"></a>本地</h3><p>本地分为两种：自旋尝试更新 &amp; 顺序更新，分别对应 CAS 更新以及锁后顺序更新。</p>
<h4 id="CAS-更新"><a href="#CAS-更新" class="headerlink" title="CAS 更新"></a>CAS 更新</h4><p>CAS 更新分为两种，AtomicInteger 以及 LongAddr。</p>
<p>AtomicInteger 应该都很熟悉，利用 volatile 关键字保证变量的可见性，自旋使用 Unsafe 提供的原子指令保证更新的准确性。</p>
<p>LongAddr 则是使用 Cell 数组保存更新指令，后续通过 sum 方法提供当前的计算结果。</p>
<h5 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">AtomicInteger</th>
<th align="center">LongAddr</th>
</tr>
</thead>
<tbody><tr>
<td align="center">计算结果</td>
<td align="center">实时</td>
<td align="center">非实时</td>
</tr>
<tr>
<td align="center">作用原理</td>
<td align="center">时间换空间（针对单变量的自旋更新）</td>
<td align="center">空间换时间（针对 Cell 数组的 CAS 更新）</td>
</tr>
<tr>
<td align="center">冲突概率</td>
<td align="center">高</td>
<td align="center">低</td>
</tr>
</tbody></table>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>重量级锁分为两种：synchronized 以及 ReentrantLock。</p>
<p>synchronized 通过 monitor enter &amp; monitor exit 内存屏障实现锁的获取与释放。</p>
<p>ReentrantLock 通过 AQS 队列保证锁获取&#x2F;释放的顺序。</p>
<h5 id="区别-1"><a href="#区别-1" class="headerlink" title="区别"></a>区别</h5><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">synchronized</th>
<th align="center">ReentrantLock</th>
</tr>
</thead>
<tbody><tr>
<td align="center">基本性质</td>
<td align="center">Java 关键字</td>
<td align="center">Java API</td>
</tr>
<tr>
<td align="center">实现方式</td>
<td align="center">内存屏障</td>
<td align="center">AQS（底层 CAS 更新）</td>
</tr>
<tr>
<td align="center">公平性控制</td>
<td align="center">只支持非公平锁</td>
<td align="center">公平锁&#x2F;非公平锁</td>
</tr>
<tr>
<td align="center">多条件绑定</td>
<td align="center">单个条件绑定</td>
<td align="center">多 Condition 绑定</td>
</tr>
<tr>
<td align="center">锁是否可升级</td>
<td align="center">无锁 -&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁</td>
<td align="center">公平锁&#x2F;非公平锁</td>
</tr>
<tr>
<td align="center">使用复杂度</td>
<td align="center">低，不用考虑锁获取&#x2F;释放过程</td>
<td align="center">高，需要手动获取&#x2F;释放锁</td>
</tr>
<tr>
<td align="center">使用灵活度</td>
<td align="center">低</td>
<td align="center">高，可支持超时获取锁、尝试获取锁，锁中断的操作</td>
</tr>
</tbody></table>
<h3 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h3><h4 id="Redis-increment-操作"><a href="#Redis-increment-操作" class="headerlink" title="Redis increment 操作"></a>Redis increment 操作</h4><p>针对单个 redis key 做递增的操作。因为 Redis 操作是单线程的，所以本质上利用了 Redis 顺序操作的特性。</p>
<h4 id="ZooKeeper-顺序节点"><a href="#ZooKeeper-顺序节点" class="headerlink" title="ZooKeeper 顺序节点"></a>ZooKeeper 顺序节点</h4><p>针对每次操作新增一个临时节点。通过计算序号的大小得到最终的结果。</p>
<h4 id="区别-2"><a href="#区别-2" class="headerlink" title="区别"></a>区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">Redis increment</th>
<th align="center">Zookeeper</th>
</tr>
</thead>
<tbody><tr>
<td align="center">计算结果</td>
<td align="center">实时</td>
<td align="center">非实时（事后计算结果）</td>
</tr>
<tr>
<td align="center">作用原理</td>
<td align="center">顺序更新</td>
<td align="center">对节点进行计数</td>
</tr>
<tr>
<td align="center">性能</td>
<td align="center">高</td>
<td align="center">低，涉及节点新增与清除</td>
</tr>
</tbody></table>
<h2 id="为什么有意思"><a href="#为什么有意思" class="headerlink" title="为什么有意思"></a>为什么有意思</h2><p>之前对于该问题，最常用就是 CAS&#x2F;锁（本地），Redis（分布式）。优点是强一致，缺点是可能的自旋等待带来的性能损耗。（时间换空间，强一致）</p>
<p>如果只要最终一致但提升性能，只能暂存中间结果最后累加，但是自己实现又涉及操作升级、扩容等管理，而 Striped64 子类则实现了上述功能。（空间换时间，最终一致）</p>
<p>之前没有将最终一致的可行性与该问题联系到一起，而这也是我觉得有意思的地方。系统设计的 trade-off 体现得尤其明显。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/05/30/spring/%E8%A7%A3%E5%86%B3%E5%9B%A0%E9%94%99%E8%AF%AF%20Mock%20%E5%AF%BC%E8%87%B4%E5%8D%95%E6%B5%8B%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/05/30/spring/%E8%A7%A3%E5%86%B3%E5%9B%A0%E9%94%99%E8%AF%AF%20Mock%20%E5%AF%BC%E8%87%B4%E5%8D%95%E6%B5%8B%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">解决因错误 Mock 导致单测慢的问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-05-30 01:04:26" itemprop="dateCreated datePublished" datetime="2025-05-30T01:04:26+00:00">2025-05-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>偶然发现单元测试运行的比较慢，比较有意思，所以就深究了一下源码，解决了一下。</p>
<h2 id="解决前后对比"><a href="#解决前后对比" class="headerlink" title="解决前后对比"></a>解决前后对比</h2><p>解决前，单测本地运行 10+ 分钟。</p>
<p>解决后，单测本地运行 1 分钟。</p>
<h2 id="项目概况"><a href="#项目概况" class="headerlink" title="项目概况"></a>项目概况</h2><p>SpringBoot 版本：2.3.x，junit 版本：5.x。</p>
<p>项目结构很简单：接收上游请求查询数据库做业务逻辑。</p>
<p>单测同时使用 @InjectMocks + @Spy&#x2F;@Mock 以及 @SpyBean&#x2F;@MockBean 对下游依赖进行 mock。</p>
<h2 id="运行时表现"><a href="#运行时表现" class="headerlink" title="运行时表现"></a>运行时表现</h2><h3 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h3><p>单元测试逻辑运行很快，运行前Spring 容器不断被启动，数据库连接 &#x2F; Bean 被重复加载。</p>
<p>而在普通业务项目中，运行时数据库 &#x2F; Bean 的信息是确定的，重复加载并没有意义。</p>
<h3 id="重复加载的-demo"><a href="#重复加载的-demo" class="headerlink" title="重复加载的 demo"></a>重复加载的 demo</h3><p>所有单测都继承 BaseTest 基类，使用集成测试的方式运行所有单测。</p>
<h4 id="业务代码"><a href="#业务代码" class="headerlink" title="业务代码"></a>业务代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class MockOuterService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private MockService mockService;</span><br><span class="line">    </span><br><span class="line">    public String mockString()&#123; return mockService.mockString();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface MockService &#123;</span><br><span class="line">    String mockString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class MockServiceImpl implements MockService&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String mockString() &#123;return &quot;business return&quot;;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//测试基类</span><br><span class="line">@TestMethodOrder(MethodOrderer.OrderAnnotation.class)</span><br><span class="line">@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.NONE, classes = SpringServiceTestApplication.class)</span><br><span class="line">@ExtendWith(MockitoExtension.class)</span><br><span class="line">public class BaseTest &#123;&#125;</span><br><span class="line"></span><br><span class="line">//集成测试</span><br><span class="line">@RunWith(JUnitPlatform.class)</span><br><span class="line">@SelectPackages(&quot;org.spring.demo.demo&quot;)</span><br><span class="line">public class TestAll extends BaseTest &#123;&#125;</span><br><span class="line"></span><br><span class="line">//业务测试 1</span><br><span class="line">class Test1 extends BaseTest &#123;</span><br><span class="line">    @InjectMocks</span><br><span class="line">    @Resource</span><br><span class="line">    private MockOuterService mockOuterService;</span><br><span class="line"></span><br><span class="line">    @Spy</span><br><span class="line">    private MockService mockService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void test()&#123;</span><br><span class="line">        Mockito.when(mockService.mockString()).thenReturn(&quot;test1 mock&quot;);</span><br><span class="line">        System.out.println(mockOuterService.mockString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//业务测试 2</span><br><span class="line">class Test2 extends BaseTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @SpyBean</span><br><span class="line">    private MockService mockService;</span><br><span class="line"></span><br><span class="line">    @Resource</span><br><span class="line">    private MockOuterService mockOuterService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    void test()&#123;</span><br><span class="line">        Mockito.when(mockService.mockString()).thenReturn(&quot;test2 mock&quot;);</span><br><span class="line">        System.out.println(mockOuterService.mockString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h4><p>Spring Boot Banner 出现两次，容器被启动两次。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/202505171114503.png"></p>
<h2 id="重复加载原因"><a href="#重复加载原因" class="headerlink" title="重复加载原因"></a>重复加载原因</h2><h3 id="常见原因"><a href="#常见原因" class="headerlink" title="常见原因"></a>常见原因</h3><p>Spring 是一个依赖上下文的框架，若上下文缓存失效&#x2F;配置变更则会重新刷新上下文，从而引发容器重启。</p>
<h3 id="推测原因"><a href="#推测原因" class="headerlink" title="推测原因"></a>推测原因</h3><p>业务项目启动过程中，Spring Boot Banner 出现一次，且所有资源（数据库连接池&#x2F;动态线程池）只初始化一遍。</p>
<p>而在单测过程中启动多次，有可能是单测改变了 Spring 上下文，或者单测与业务代码结合有问题。</p>
<h3 id="最小可行性分析"><a href="#最小可行性分析" class="headerlink" title="最小可行性分析"></a>最小可行性分析</h3><p>在对单测删减到最后两个类，仅使用 @MockBean 或者 @InjectMocks&#x2F;@Mock 时，容器启动一次。同时使用，容器启动两次。</p>
<p>所以原因应该是 SpringBoot 封装的与 Mockito 原生的同时作用情况下，改变了 Spring 的上下文。</p>
<h3 id="根本原因"><a href="#根本原因" class="headerlink" title="根本原因"></a>根本原因</h3><h4 id="MockBean-x2F-SpyBean-作用原理"><a href="#MockBean-x2F-SpyBean-作用原理" class="headerlink" title="@MockBean&#x2F;@SpyBean 作用原理"></a>@MockBean&#x2F;@SpyBean 作用原理</h4><p>整体流程分为注册与使用两部份。</p>
<p>注册方面</p>
<ol>
<li>Junit 通过 Extension 形式提供单元测试各执行流程的自定义逻辑扩展能力。</li>
<li>Spring 自定义 Extension 子类 SpringExtension，并通过执行不同 TestExecutionListener 执行 TestContextManager 自定义内容。</li>
<li>Spring 通过 ContextCustomizerFactory 形式提供动态修改上下文的能力，SpringBoot test 实现子类用于 Mock 相关逻辑实现。</li>
<li>SpringBoot test自定义 ContextCustomizerFactory 子类 MockitoContextCustomizerFactory，用于 Mock 相关逻辑实现。</li>
</ol>
<p>使用方面</p>
<p>Junit 通过执行不同 Extension 实现自定义逻辑，进而一层层触发到 SpringBoot test 实现的 Mock 相关逻辑。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/202505272303876.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">group 注册扩展</span><br><span class="line">    group junit5 内部流程</span><br><span class="line">        &quot;MethodBasedTestDescriptor&quot; -&gt; &quot;ExtensionUtils&quot;: 扫描 @Test，调用 Extension 注册</span><br><span class="line">        &quot;ExtensionUtils&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 调用注册</span><br><span class="line">        &quot;MutableExtensionRegistry&quot; -&gt; &quot;SpringExtension&quot;: 注册 Extension</span><br><span class="line">    end</span><br><span class="line">    group Spring Framework 逻辑</span><br><span class="line">        &quot;SpringExtension&quot; -&gt; &quot;TestContextManager&quot;: 新建 TestContextManager</span><br><span class="line">        &quot;TestContextManager&quot; -&gt; &quot;BootstrapUtils&quot;: 触发 @BootstrapWith 扫描逻辑</span><br><span class="line">        &quot;BootstrapUtils&quot; -&gt; &quot;TestContextManager&quot;: 返回启动类</span><br><span class="line">        &quot;TestContextManager&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 触发启动类 buildTestContext</span><br><span class="line">    end</span><br><span class="line">    group SpringBoot 逻辑</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 扫描执行 ContextCustomizerFactory 逻辑</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;MockitoContextCustomizerFactory&quot;: Mockito 自定义上下文类</span><br><span class="line">        &quot;MockitoContextCustomizerFactory&quot; -&gt; &quot;DefinitionsParser&quot;: 注册注解扫描器</span><br><span class="line">        &quot;DefinitionsParser&quot; -&gt; &quot;DefinitionsParser&quot;: 扫描 @SpyBean/@MockBean 添加到 Definition 集合中</span><br><span class="line">        &quot;DefinitionsParser&quot; -&gt; &quot;MockitoContextCustomizerFactory&quot;: 返回 Definition 集合</span><br><span class="line">        &quot;MockitoContextCustomizerFactory&quot; -&gt; &quot;MockitoContextCustomizerFactory&quot;: 以 Definition 集合构建 ContextCustomizer</span><br><span class="line">        &quot;MockitoContextCustomizerFactory&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 返回 ContextCustomizer</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 构建 MergedContextConfiguration</span><br><span class="line">        &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;SpringBootTestContextBootstrapper&quot;: 构建 TestContext</span><br><span class="line">    end </span><br><span class="line">    &quot;SpringBootTestContextBootstrapper&quot; -&gt; &quot;TestContextManager&quot;: 返回 TestContext</span><br><span class="line">    &quot;TestContextManager&quot; -&gt; &quot;TestContextManager&quot;: 存储上下文</span><br><span class="line">    &quot;TestContextManager&quot; -&gt; &quot;SpringExtension&quot;: 返回 TestContextManager 实例</span><br><span class="line">    &quot;SpringExtension&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 返回 SpringExtension 实例</span><br><span class="line">    &quot;MutableExtensionRegistry&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 存储各 Extension 实例</span><br><span class="line">end</span><br><span class="line">group 使用扩展</span><br><span class="line">    &quot;NodeTestTask&quot; -&gt; &quot;ClassBasedTestDescriptor&quot;: prepare</span><br><span class="line">    &quot;ClassBasedTestDescriptor&quot; -&gt; &quot;SpringExtension&quot;: TestInstancePostProcessor#postProcessTestInstance </span><br><span class="line">    &quot;SpringExtension&quot; -&gt; &quot;TestContextManager&quot;: prepareTestInstance</span><br><span class="line">    &quot;TestContextManager&quot; -&gt; &quot;DependencyInjectionTestExecutionListener&quot;: 传入 SpringBootTestContextBootstrapper 构建的 TestContext 到 prepareTestInstance</span><br><span class="line">    &quot;DependencyInjectionTestExecutionListener&quot; -&gt; &quot;DependencyInjectionTestExcutionListener&quot;: 创建完整 Spring Bean 依赖</span><br><span class="line">end</span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="InjectMocks-Spy-x2F-Mock-作用原理"><a href="#InjectMocks-Spy-x2F-Mock-作用原理" class="headerlink" title="@InjectMocks +@Spy&#x2F;@Mock 作用原理"></a>@InjectMocks +@Spy&#x2F;@Mock 作用原理</h4><p>整体流程分为注册与使用两部份。</p>
<p>注册方面，只是将自定义扩展挂载到 Junit 钩子上。</p>
<p>使用方面，扫描当前单测类相关注释，反射注入新增的 mock 对象。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/202505300027369.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">group 注册扩展</span><br><span class="line">    group junit5 内部流程</span><br><span class="line">        &quot;MethodBasedTestDescriptor&quot; -&gt; &quot;ExtensionUtils&quot;: 扫描 @Test，调用 Extension 注册</span><br><span class="line">        &quot;ExtensionUtils&quot; -&gt; &quot;MutableExtensionRegistry&quot;: 调用注册</span><br><span class="line">        &quot;MutableExtensionRegistry&quot; -&gt; &quot;MockitoExtension&quot;: 注册 Extension</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">group 使用扩展</span><br><span class="line">    group junit5 内部流程</span><br><span class="line">        &quot;NodeTestTask&quot; -&gt; &quot;TestMethodTestDescriptor&quot;: execute</span><br><span class="line">        &quot;TestMethodTestDescriptor&quot; -&gt; &quot;TestMethodTestDescriptor&quot;: TestMethodTestDescriptor#invokeBeforeEachCallbacks </span><br><span class="line">        &quot;TestMethodTestDescriptor&quot; -&gt; &quot;MockitoExtension&quot;: beforeEach</span><br><span class="line">    end</span><br><span class="line">    group mockito 内部流程</span><br><span class="line">        &quot;MockitoExtension&quot; -&gt; &quot;DefaultMockitoSessionBuilder&quot;: startMocking</span><br><span class="line">        &quot;DefaultMockitoSessionBuilder&quot; -&gt; &quot;DefaultMockitoSession&quot;: new DefaultMockitoSession Object </span><br><span class="line">        &quot;DefaultMockitoSession&quot; -&gt; &quot;MockitoAnnotations&quot;: openMocks</span><br><span class="line">        &quot;MockitoAnnotations&quot; -&gt; &quot;InjectingAnnotationEngine&quot;: process</span><br><span class="line">        &quot;InjectingAnnotationEngine&quot; -&gt; &quot;MockScanner&quot;: processIndependentAnnotations/injectCloseableMocks 传入当前单测类</span><br><span class="line">        &quot;MockScanner&quot; -&gt; &quot;MockScanner&quot;: 扫描修饰 @Mock/@Spy 变量</span><br><span class="line">        &quot;MockScanner&quot; -&gt; &quot;InjectingAnnotationEngine&quot;: 返回扫描结果</span><br><span class="line">        &quot;InjectingAnnotationEngine&quot; -&gt; &quot;InjectingAnnotationEngine&quot;: 执行 mock 注入</span><br><span class="line">        &quot;InjectingAnnotationEngine&quot; -&gt; &quot;DefaultInjectionEngine&quot;: injectMocksOnFields 反射注入</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">@enduml</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="二者原理区别"><a href="#二者原理区别" class="headerlink" title="二者原理区别"></a>二者原理区别</h3><table>
<thead>
<tr>
<th></th>
<th align="center">SpringBoot</th>
<th align="left">Mockito 原生</th>
</tr>
</thead>
<tbody><tr>
<td>执行时机</td>
<td align="center">单测类初始化（ClassBasedTestDescriptor）</td>
<td align="left">单测方法（TestMethodTestDescriptor）</td>
</tr>
<tr>
<td>注入对象</td>
<td align="center">缓存的 Spring Bean</td>
<td align="left">调用 Java 原生反射构建</td>
</tr>
</tbody></table>
<h3 id="原因确定"><a href="#原因确定" class="headerlink" title="原因确定"></a>原因确定</h3><p>根据二者的作用原理可知，Mockito 将 Spring Bean 依赖链改变，进而引发 Spring 容器的启动。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>根据原因可知，解决方案二选一：SpringBoot 的&#x2F;Mockito 原生的。</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">SpringBoot</th>
<th align="center">Mockito 原生</th>
</tr>
</thead>
<tbody><tr>
<td align="center">针对对象</td>
<td align="center">Spring Bean</td>
<td align="center">所有的对象</td>
</tr>
<tr>
<td align="center">使用复杂度</td>
<td align="center">低，不需管理依赖链</td>
<td align="center">高，需要手动注入被依赖的对象</td>
</tr>
<tr>
<td align="center">作用场景</td>
<td align="center">需 Spring 环境的集成测试</td>
<td align="center">纯单元测试</td>
</tr>
</tbody></table>
<h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>因为项目中使用 SpringBoot ，并且单元测试大多以集成测试的方式运行，结合使用的复杂度，所以选择了 SpringBoot 提供的方案。</p>
<h2 id="仍需提升的"><a href="#仍需提升的" class="headerlink" title="仍需提升的"></a>仍需提升的</h2><p>目前 <strong><code>junit-platform.properties</code></strong> 配置的策略为测试类串行&#x2F;测试方法并行，希望改成测试类并行&#x2F;测试方法并行，进一步提升速度。</p>
<p>但修改后发现大部份单测都报错了，仍需明确原因，推测是各单测自定义 mock 行为互相影响导致。</p>
<h2 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h2><p>通过表象猜测原因，通过源码证明猜想。</p>
<p>在猜测原因时，就在想 SpringBoot 不可能只为了 KPI 而集成 Mockito，肯定有结合 Mockito 做对应的集成，方便后续使用。</p>
<p>追查源码后印证了猜想，满足。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/02/05/JAVA/synchronized,%20volatile%20%E5%9C%A8%20DCL%20%E7%9A%84%E4%BD%9C%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/02/05/JAVA/synchronized,%20volatile%20%E5%9C%A8%20DCL%20%E7%9A%84%E4%BD%9C%E7%94%A8/" class="post-title-link" itemprop="url">synchronized, volatile 在 DCL 的作用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-02-05 08:00:06" itemprop="dateCreated datePublished" datetime="2025-02-05T08:00:06+00:00">2025-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>最近在看设计模式，在单例模式的 Double Check Lock（DCL）中，存在两个关键字：volatile &amp; synchronized。</p>
<p>之前都知道 DCL 怎么写，直接套娃。但是这两关键字在单例里面的作用还没深究过，于是就自言自语一篇文章。</p>
<h2 id="单例模式代码"><a href="#单例模式代码" class="headerlink" title="单例模式代码"></a>单例模式代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Single</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Single INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Single</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Single <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//first check object</span></span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//locks in the class dimension</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Single.class)&#123;</span><br><span class="line">                <span class="comment">//second check object</span></span><br><span class="line">                <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>)&#123;</span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Single</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="synchronized-amp-volatile-作用"><a href="#synchronized-amp-volatile-作用" class="headerlink" title="synchronized &amp; volatile 作用"></a>synchronized &amp; volatile 作用</h2><h3 id="synchronized-作用"><a href="#synchronized-作用" class="headerlink" title="synchronized 作用"></a>synchronized 作用</h3><p>synchronized 是 java 的重量级锁，可作用于方法维度、代码块维度。具体到底层字节码就是 monitor enter &amp; monitor exit。 </p>
<h3 id="volatile-作用"><a href="#volatile-作用" class="headerlink" title="volatile 作用"></a>volatile 作用</h3><p>volatile 有两个作用</p>
<ol>
<li>保证可见性。</li>
</ol>
<p>修饰的变量从主内存 copy 到工作内存，修改后写回到主内存。</p>
<p>作用原理就是读写前 JVM 加一个内存屏障，通过 happen before 原则确保修改可见于读取。</p>
<blockquote>
<p>主内存：类比成 JVM 堆</p>
<p>工作内存：类比成 JVM 虚拟机栈</p>
</blockquote>
<ol start="2">
<li>禁止指令重排序。</li>
</ol>
<h2 id="对象初始化步骤"><a href="#对象初始化步骤" class="headerlink" title="对象初始化步骤"></a>对象初始化步骤</h2><ol>
<li>分配内存空间</li>
<li>实例变量初始化</li>
<li>执行初始化代码块</li>
<li>调用构造函数</li>
<li>静态变量初始化</li>
<li>返回对象引用</li>
</ol>
<p>刨除非必要步骤，上述 6 步剩下 3 步</p>
<ol>
<li>分配内存空间</li>
<li>调用构造函数</li>
<li>返回对象引用</li>
</ol>
<h2 id="synchronized-amp-volatile-在-DCL-缺失的问题"><a href="#synchronized-amp-volatile-在-DCL-缺失的问题" class="headerlink" title="synchronized &amp; volatile 在 DCL 缺失的问题"></a>synchronized &amp; volatile 在 DCL 缺失的问题</h2><h3 id="有-synchronized-没有-volatile"><a href="#有-synchronized-没有-volatile" class="headerlink" title="有 synchronized 没有 volatile"></a>有 synchronized 没有 volatile</h3><p>由于指令重排序的优化手段，上述创建对象的 1 -&gt; 2 -&gt; 3, 可能顺序变成了 1 -&gt; 3 -&gt; 2。</p>
<p>没有禁止重排序，顺序变了，中间的第三步返回是个空对象，并发情况下就 G 了，另一线程拿的是空对象。</p>
<h3 id="有-volatile-没有-synchronized"><a href="#有-volatile-没有-synchronized" class="headerlink" title="有 volatile 没有 synchronized"></a>有 volatile 没有 synchronized</h3><p>并发情况下， A B 两个线程都通过了等于 null 的校验，开始执行创建对象的操作。</p>
<p>上述创建对象说的 1 -&gt; 2 -&gt; 3， A B 两个线程都有可能走完 1 &amp; 2，最后单例对象会是执行慢的线程返回引用的那个。构造函数会执行两遍，违反了单例模式的初衷。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>synchronized &amp; volatile 的作用就很明显。</p>
<p>synchronized 保障构造函数只执行一遍，对象也只有一个。</p>
<p>volatile 保障极端情况下不会返回空对象。</p>
<h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><ol>
<li>为什么 synchronized 修饰的是代码块，不是静态方法 getInstance ?</li>
</ol>
<p>为了提升获取单例对象的运行效率。</p>
<p>synchronized 修饰代码块，只会影响进入代码块瞬间的其他线程。</p>
<p>synchronized 修饰方法，会影响调用方法的所有线程。</p>
<ol start="2">
<li>为什么进入 synchronized 修饰代码块后，还要判断一下单例对象是否等于 null ？</li>
</ol>
<p>防止重复创建对象。</p>
<p>假设 A B 两个线程</p>
<ol>
<li>A 线程进入同步块，还在上述说的对象初始化三步里面，B 线程进来了，在 synchronized 代码块外自旋。</li>
<li>A 线程执行完了，B 线程进代码块了，这时若不判断是否为 null，就会重复创建对象。</li>
</ol>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2025/01/05/JAVA/keepAliveTime%20%E5%90%AB%E4%B9%89/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2025/01/05/JAVA/keepAliveTime%20%E5%90%AB%E4%B9%89/" class="post-title-link" itemprop="url">ThreadPoolExecutor keepAliveTime 含义</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2025-01-05 08:00:06" itemprop="dateCreated datePublished" datetime="2025-01-05T08:00:06+00:00">2025-01-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在线上环境排查问题时，某个线程池在某个时间点新建线程达到设定的最大线程数 maximumPoolSize，后续流量降低后当前线程数仍未回落，仍然为最大线程数，阻塞队列中有任务，但是活跃线程数显著减少。</p>
<h2 id="之前的认知"><a href="#之前的认知" class="headerlink" title="之前的认知"></a>之前的认知</h2><p>固有的认知中，线程池运行原理：<code>java.util.concurrent.ThreadPoolExecutor#execute</code></p>
<ol>
<li>线程池内部维护 corePoolSize 个线程</li>
<li>任务提交后，若核心线程都已被占用，则添加到阻塞队列</li>
<li>阻塞队列已满，则新建线程直到线程数到达 maximumPoolSize</li>
<li>若阻塞队列已满，并且线程数到达 maximumPoolSize，则执行拒绝策略</li>
<li>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，进行销毁。</li>
</ol>
<h2 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h2><p>认知第五点中：超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，进行销毁。明显与现象不符。现象肯定没问题的，就是认知有问题了：超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，至少不会马上销毁。</p>
<h2 id="现实与认知的问题"><a href="#现实与认知的问题" class="headerlink" title="现实与认知的问题"></a>现实与认知的问题</h2><ol>
<li>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，会不会销毁？</li>
<li>销毁的时机是？</li>
<li>为什么线程池中大多为休眠线程？线程池的线程数仍为最大线程数？</li>
</ol>
<h2 id="重塑认知"><a href="#重塑认知" class="headerlink" title="重塑认知"></a>重塑认知</h2><p>答案都在源码内</p>
<h3 id="ThreadPoolExecutor-执行任务流程"><a href="#ThreadPoolExecutor-执行任务流程" class="headerlink" title="ThreadPoolExecutor 执行任务流程"></a>ThreadPoolExecutor 执行任务流程</h3><h3 id="线程池使用-demo"><a href="#线程池使用-demo" class="headerlink" title="线程池使用 demo"></a>线程池使用 demo</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(1, 10, 100, TimeUnit.MINUTES, new ArrayBlockingQueue&lt;&gt;(1000));</span><br><span class="line">        threadPoolExecutor.execute(() -&gt; System.out.println(&quot;print in thread&quot;));</span><br></pre></td></tr></table></figure>



<h3 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h3><p><code>java.util.concurrent.ThreadPoolExecutor#execute</code></p>
<p>流程就是之前认知中 1 - 4 点，在第三点中蕴含一个重要变量：<code>java.util.concurrent.ThreadPoolExecutor#workers</code>，这个就是ThreadPoolExecutor 管理线程的对象</p>
<h3 id="workers-移除流程"><a href="#workers-移除流程" class="headerlink" title="workers 移除流程"></a>workers 移除流程</h3><p>源码上看，只有以下两个方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.ThreadPoolExecutor#addWorkerFailed</span><br><span class="line">java.util.concurrent.ThreadPoolExecutor#processWorkerExit</span><br></pre></td></tr></table></figure>

<p>望文生义，addWorkerFailed 作用为添加 worker 后的失败补偿动作，可以忽略这个方法。</p>
<p>所以正常的销毁动作，肯定是在 processWorkerExit 中。</p>
<h3 id="processWorkerExit-执行流程"><a href="#processWorkerExit-执行流程" class="headerlink" title="processWorkerExit 执行流程"></a>processWorkerExit 执行流程</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><p>仅在<code>java.util.concurrent.ThreadPoolExecutor#runWorker</code> 中 finally 执行</p>
<p>而 runWorker 则是任务执行的底层方法，那么这意味着：任务执行完，满足某几个前提条件就会销毁线程。那么前提条件是什么呢？</p>
<h4 id="runWorker-执行流程"><a href="#runWorker-执行流程" class="headerlink" title="runWorker 执行流程"></a>runWorker 执行流程</h4><ol>
<li>while 循环调用 <code>java.util.concurrent.ThreadPoolExecutor#getTask</code> 获取任务<ol>
<li>获取到任务后，走真实执行任务流程，beforeExecute&#x2F;run&#x2F;afterExecute</li>
<li>获取不到任务，则到 processWorkerExit 执行</li>
</ol>
</li>
</ol>
<h4 id="getTask-执行流程"><a href="#getTask-执行流程" class="headerlink" title="getTask 执行流程"></a>getTask 执行流程</h4><ol>
<li>使用当前 worker 数与核心线程数关系判定变量 timed</li>
<li>根据 timed 判定 <code>timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take()</code></li>
</ol>
<p>keepAliveTime 第一次出现，并且是用于在当前 worker 数大于核心线程数情况下从阻塞队列中获取元素。</p>
<p>那么，控制 processWorkerExit 执行的前提条件：当前 worker 数大于核心线程数，并且从阻塞队列经过 keepAliveTime 拿不到任务。</p>
<p>但这个前提条件明显跟现象不符，那肯定是 <code>workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS)</code> 中被阻塞了，导致实际获取任务时间 &gt; keepAliveTime。</p>
<h4 id="workQueue-poll-执行流程（以-ArrayBlockingQueue-为例）"><a href="#workQueue-poll-执行流程（以-ArrayBlockingQueue-为例）" class="headerlink" title="workQueue.poll 执行流程（以 ArrayBlockingQueue 为例）"></a>workQueue.poll 执行流程（以 ArrayBlockingQueue 为例）</h4><ol>
<li>获取 ArrayBlockingQueue 全局锁</li>
<li>当队列元素个数 &#x3D; 0， 则 await keepAliveTime 时间</li>
<li>队列元素个数 !&#x3D; 0，出队元素</li>
<li>释放 ArrayBlockingQueue 全局锁</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123;</span><br><span class="line">        long nanos = unit.toNanos(timeout);</span><br><span class="line">        final ReentrantLock lock = this.lock;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        try &#123;</span><br><span class="line">            while (count == 0) &#123;</span><br><span class="line">                if (nanos &lt;= 0)</span><br><span class="line">                    return null;</span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            return dequeue();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="真相"><a href="#真相" class="headerlink" title="真相"></a>真相</h2><p>从workQueue.poll 执行流程中，能明显看到线程 await 的前提是获取到队列的全局锁，并且队列元素 &#x3D; 0。</p>
<p>整理一遍就是：</p>
<p>当线程获取到队列全局锁，并且当前队列为空，await keepAliveTime 后，若当前队列为空，则执行销毁方法。</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/master/20250105161217.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line"></span><br><span class="line">&quot;Thread&quot; -&gt; &quot;BlockingQueue&quot;: pool task</span><br><span class="line">&quot;Thread&quot; -&gt; &quot;BlockingQueue&quot;: get global ReentrantLock</span><br><span class="line">alt get global ReentrantLock success</span><br><span class="line">    alt BlockingQueue size = 0</span><br><span class="line">        &quot;Thread&quot; -&gt; &quot;Condition&quot;: await keepAliveTime</span><br><span class="line">        &quot;BlockingQueue&quot; -&gt; &quot;Thread&quot;: non task，execute processWorkerExit method</span><br><span class="line">    else</span><br><span class="line">        &quot;BlockingQueue&quot; -&gt; &quot;Thread&quot;: first task in queue</span><br><span class="line">        &quot;Thread&quot; -&gt; &quot;Thread&quot;: keep execute task</span><br><span class="line">    end</span><br><span class="line">else </span><br><span class="line">    &quot;Thread&quot; -&gt; &quot;BlockingQueue&quot;: keep acquire ReentrantLock</span><br><span class="line">end</span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<p>那么上述提到的两个问题</p>
<ol>
<li>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，会不会销毁？</li>
<li>销毁的时机是？</li>
<li>为什么线程池中大多为休眠线程？线程池的线程数仍为最大线程数？</li>
</ol>
<p>就有了答案</p>
<ol>
<li><p>超过 corePoolSize 部分的空闲线程，到达 keepAliveTime 后，有可能销毁，前提是拿到队列的全局锁。</p>
</li>
<li><p>销毁的时机是当前线程获取到队列全局锁，并且队列元素 &#x3D; 0，并且 await 后队列元素仍然为 0</p>
</li>
<li><p>因为线上提交任务刚好够核心线程消费，并且残留少数任务在阻塞队列中。在并发情况下，大部分线程都 await，线程池只能新增 worker 处理了。</p>
</li>
</ol>
<h2 id="自言自语"><a href="#自言自语" class="headerlink" title="自言自语"></a>自言自语</h2><h3 id="怎么解决当前线程数-x3D-最大线程数，并且活跃线程较少的情况？"><a href="#怎么解决当前线程数-x3D-最大线程数，并且活跃线程较少的情况？" class="headerlink" title="怎么解决当前线程数 &#x3D; 最大线程数，并且活跃线程较少的情况？"></a>怎么解决当前线程数 &#x3D; 最大线程数，并且活跃线程较少的情况？</h3><ol>
<li>调高 corePoolSize ，使线程池不新增 corePoolSize 之外的线程。</li>
<li>调低 keepAliveTime &amp; TimeUnit 的值，使休眠线程快速被销毁。</li>
</ol>
<p>在商业开发的角度上，比较难精准实现。</p>
<ol>
<li>业务发展速度很快， corePoolSize 在将来的一段时间内就不适合了。</li>
<li>加快休眠线程的销毁，意味着存在频繁新建线程的问题，会影响系统稳定性。</li>
</ol>
<h3 id="为什么-await-keepAliveTime后不直接销毁？还尝试出队元素？"><a href="#为什么-await-keepAliveTime后不直接销毁？还尝试出队元素？" class="headerlink" title="为什么 await keepAliveTime后不直接销毁？还尝试出队元素？"></a>为什么 await keepAliveTime后不直接销毁？还尝试出队元素？</h3><p>这就回到 java 线程与操作系统线程的映射关系。</p>
<p>线程模型有三种：一对一，多对一，一对多。java 在大多数平台上都是一对一。</p>
<ol>
<li>如果直接销毁，核心线程处理不过来情况下，线程池会频繁销毁&#x2F;新建线程，消耗系统的资源。</li>
<li>尝试出队元素，double check 线程池的负载，负载高则继续处理，负载较低则销毁线程，达到节省资源的目的。</li>
</ol>
<h3 id="keepAliveTime-的理解"><a href="#keepAliveTime-的理解" class="headerlink" title="keepAliveTime 的理解"></a>keepAliveTime 的理解</h3><p>源码中的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">when the number of threads is greater than the core, this is the maximum time that excess idle threads will wait for new tasks before terminating.</span><br><span class="line"></span><br><span class="line">当线程数大于 Core 数时，这是多余的空闲线程在终止之前等待新任务的最长时间。</span><br></pre></td></tr></table></figure>

<p>之前以为是线程数大于 Core 数时，空闲线程的存活时间。过了 keepAliveTime 就执行销毁。</p>
<p>现在认识到：线程数大于 Core 数时，空闲线程的存活时间 &gt;&#x3D; keepAliveTime （没获取到队列锁的情况下），并且销毁前 double check 是否有任务，没有才执行销毁。</p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2023/11/05/cache/Redis%20%E7%9A%84%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/11/05/cache/Redis%20%E7%9A%84%E4%B8%89%E7%A7%8D%E9%83%A8%E7%BD%B2%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">Redis 的三种部署模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-11-05 17:35:40" itemprop="dateCreated datePublished" datetime="2023-11-05T17:35:40+00:00">2023-11-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>提前叠个 buff：这个文章不涉及图（画起来比较麻烦），只是记录我的胡思乱想。</p>
<blockquote>
<p>redis 从单点 -&gt; 集群总共有三个部署模式：单机模式，主从模式，哨兵模式，集群模式</p>
</blockquote>
<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>新手入门模式。单机模式意味着 Redis 是单点的，部署在一台服务器，挂了就挂了，用在本地测试还可以，但是生产环境就算了。</p>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ol>
<li>部署简单</li>
<li>省钱，一台服务器就可以了</li>
<li>不涉及主从复制等，数据强一致</li>
</ol>
<h4 id="劣势"><a href="#劣势" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>单点意味着稳定性基本上为 0，挂了就挂了</li>
<li>吞吐量受限于单机资源</li>
</ol>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>当流量越来越大，单台机器资源不能无限增长，就需要水平扩展到多个节点，使用多个节点分散承接读流量。</p>
<p>主从模式为主节点承接写流量，从节点承接读流量，二者数据一致通过主节点异步复制（全量复制 &#x2F; 增量复制）到从节点。</p>
<h4 id="优势-1"><a href="#优势-1" class="headerlink" title="优势"></a>优势</h4><ol>
<li>读流量被分摊到多个节点上，读流量支持力度变大</li>
<li>当主节点宕机&#x2F;不可用时，可以手动切换主节点继续提供服务</li>
</ol>
<h4 id="劣势-1"><a href="#劣势-1" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>当主节点宕机&#x2F;不可用时手动切换节点，切换过程中 redis （主节点）不可用，并且会丢失主节点 &#x2F; 从节点之间未同步的数据</li>
<li>稳定性还是不够，依赖手动切换。不适用于生产。</li>
<li>写流量还是让主节点独自承受，写流量还是靠单机资源支撑</li>
</ol>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>哨兵模式主要解决主从模式中手动切换的部分，本质上哨兵代替了人，通过 gossip 协议监控主节点的健康情况。</p>
<h4 id="优势-2"><a href="#优势-2" class="headerlink" title="优势"></a>优势</h4><ol>
<li>不用手动切换主节点了，切换过程中虽然 redis 也是不可用的，但是这个时间会极大的降低</li>
</ol>
<h4 id="劣势-2"><a href="#劣势-2" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>sentinel 与主节点多了一层心跳检测，有可能 sentinel 与主节点的网络抖动导致重新选举主节点。</li>
<li>redis 主从节点吞吐因心跳检测可能稍微降低。</li>
</ol>
<h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p>集群模式主要解决了两个问题：写流量水平扩展 &amp; 哨兵与主节点的网络抖动。</p>
<p>集群模式主要的架构为：主节点平分 16384 个槽，集群支持主节点的动态上线&#x2F;下线（需要 rehash），主节点与从节点通过心跳关联，主节点失联后从节点有权发起选举成为主节点（raft 算法）。</p>
<h4 id="优势-3"><a href="#优势-3" class="headerlink" title="优势"></a>优势</h4><ol>
<li>自管理集群内主从节点上下线，减少因外部集群网络抖动之类的发起的无效选举</li>
<li>数据按照 slot 存放在多个节点，客户端通过服务端主节点的重定向跳转到具体的槽，可动态调整数据分布</li>
<li>减少了集群整体不可用的概率，某一主节点宕机只影响一部分数据的访问</li>
<li>写流量 &amp; 数据平分到多个节点，集群的写请求瓶颈得到缓解</li>
</ol>
<h4 id="劣势-3"><a href="#劣势-3" class="headerlink" title="劣势"></a>劣势</h4><ol>
<li>集群间状态同步使用 gossip 协议，节点数较多存在较多的心跳网络流量</li>
<li>主节点的上线&#x2F;下线需要进行 rehash ，当节点内数据较多耗时较长</li>
</ol>
<blockquote>
<p>redis 节点间复制有两种：全量复制 &amp; 部分复制</p>
</blockquote>
<h3 id="全量复制"><a href="#全量复制" class="headerlink" title="全量复制"></a>全量复制</h3><h4 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h4><ol>
<li>从节点刚上线需要同步主节点的数据</li>
<li>从节点切换脑裂后从节点偏移量与主节点不一致的时间点</li>
<li>从节点偏移量不在主节点的复制缓冲区中</li>
</ol>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>从节点向主节点发起同步数据的请求</li>
<li>主节点通过 bgsave 形成当前数据的快照，发给从节点</li>
<li>从节点删除历史数据，加载主节点发过来 RDB 文件</li>
<li>从节点拉取主节点缓冲区数据，加载到自身的内存中，并更新当前的偏移量</li>
</ol>
<h3 id="部分复制"><a href="#部分复制" class="headerlink" title="部分复制"></a>部分复制</h3><h4 id="出现场景-1"><a href="#出现场景-1" class="headerlink" title="出现场景"></a>出现场景</h4><ol>
<li>全量复制出现场景之外的场景</li>
<li>主从日常复制</li>
</ol>
<p>过程</p>
<ol>
<li>主节点将命令同步到缓冲区（AOF）</li>
<li>从节点拉取缓冲区数据，更新到自身的节点中，并更新当前的偏移量</li>
</ol>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2023/06/10/cache/%E8%80%81%E8%AF%9D%E6%96%B0%E8%B0%88%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/06/10/cache/%E8%80%81%E8%AF%9D%E6%96%B0%E8%B0%88%E4%B9%8B%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/" class="post-title-link" itemprop="url">老话新谈之缓存一致性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-06-10 17:05:42" itemprop="dateCreated datePublished" datetime="2023-06-10T17:05:42+00:00">2023-06-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>缓存一致性常见的更新策略也比较多，如先更新数据库再更新缓存，先删缓存再更新数据库等等，我在理解的时候有些混乱，所以这个文章提供了一些理解上的技巧去理解缓存一致性。</p>
<h3 id="为什么会有缓存一致性的问题"><a href="#为什么会有缓存一致性的问题" class="headerlink" title="为什么会有缓存一致性的问题"></a>为什么会有缓存一致性的问题</h3><ol>
<li>缓存与数据库是两套中间件，存在网络抖动之类的原因导致没有更新任一方的可能</li>
<li>数据库大多都是事务型的中间件，支持错误回滚，缓存大多是非事务型的中间件，这里缓存更新失败了没办法回滚</li>
</ol>
<p>所以根因是缓存大部分不支持事务无法回滚。</p>
<h3 id="怎么尽量解决缓存一致性的问题"><a href="#怎么尽量解决缓存一致性的问题" class="headerlink" title="怎么尽量解决缓存一致性的问题"></a>怎么尽量解决缓存一致性的问题</h3><p>操作二者必定有先后顺序，存在以下两个情况：</p>
<ol>
<li>先操作缓存，再操作数据库。操作缓存成功，数据库更新失败，缓存无法回滚，数据不一致</li>
<li>先操作数据库，再操作缓存。操作数据库成功，缓存操作失败，可触发异常回滚数据库，数据一致</li>
</ol>
<p>根据上述所列，只能先操作数据库，再操作缓存了。</p>
<p>操作缓存也分两种：</p>
<ol>
<li>更新缓存数据，可能并发请求，后一请求更新缓存的数据被前一请求的更新覆盖了，导致数据不一致</li>
<li>删除缓存数据，并发请求，二者都使缓存失效，查询请求将数据库数据加载到缓存中，数据一致</li>
</ol>
<p>根据上述所列，只能使缓存失效，查询请求加载数据到缓存中了。</p>
<blockquote>
<p>所以，如果在不加任何重试措施的情况下，先操作数据库，再删除缓存是一个容错较好的方法。</p>
</blockquote>
<h3 id="缓存一致性的分类-amp-存在的问题"><a href="#缓存一致性的分类-amp-存在的问题" class="headerlink" title="缓存一致性的分类 &amp; 存在的问题"></a>缓存一致性的分类 &amp; 存在的问题</h3><h4 id="Client-维护缓存-amp-数据库的一致性"><a href="#Client-维护缓存-amp-数据库的一致性" class="headerlink" title="Client 维护缓存 &amp; 数据库的一致性"></a>Client 维护缓存 &amp; 数据库的一致性</h4><ol>
<li><p>更新缓存 -&gt; 更新数据库</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230606213304.png" alt="图片1"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; Cache: update data</span><br><span class="line">transaction1 &lt;-- Cache: update result</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; DB: update data</span><br><span class="line">transaction1 &lt;-- DB: update result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<ul>
<li>可能出现的数据不一致</li>
</ul>
<p>​    数据不一致：更新缓存成功了，更新数据库失败了，有数据不一致的问题，直到缓存超时失效或又一更新请求操作成功都会不一致</p>
<ul>
<li><p>改进方式</p>
<p>若保证更新数据仅有少数的服务更新，可以将更新数据库请求入队处理，且可加入重试机制。但是队列的加入会增大系统复杂度，并且重试以及缓存更新顺序不一致会加剧数据不一致</p>
</li>
</ul>
<ol start="2">
<li>更新数据库 -&gt; 更新缓存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230606215720.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; DB: update data</span><br><span class="line">transaction1 &lt;-- DB: update result</span><br><span class="line"></span><br><span class="line">transaction2 -&gt; DB: update data</span><br><span class="line">transaction2 &lt;-- DB: update result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">transaction2 -&gt; Cache: update data</span><br><span class="line">transaction2 &lt;-- Cache: update result</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; Cache: update data</span><br><span class="line">transaction1 &lt;-- Cache: update result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li>可能出现的数据不一致</li>
</ul>
<p>​        数据不一致：如 t1 先更新数据库，t2 在 t1 更新缓存前把数据库缓存都更新完了，t1 再更新缓存，这时候缓存上是 t1 的数据，数据库是 t2 的数据</p>
<ul>
<li><p>改进方式</p>
<p>若保证更新数据仅有少数的服务更新，可以将更新数据库请求入队处理，但是队列更新的引入增大了系统复杂度</p>
</li>
</ul>
<ol start="3">
<li><p>删除缓存 -&gt; 更新数据库</p>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610163854.png"></p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; Cache: delete data</span><br><span class="line"></span><br><span class="line">query1 -&gt; DB: select data</span><br><span class="line">query1 -&gt; Cache: insert data</span><br><span class="line"></span><br><span class="line">transaction1 -&gt; DB: update result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li><p>可能出现的数据不一致</p>
<ol>
<li>如图所示，更新请求先删除缓存，查询请求从缓存获取不到数据从数据库获取数据（老数据）加载到缓存中，更新请求更新数据库</li>
<li>这样的流程会导致查询请求加载老数据到缓存中，后续更新请求更新新数据到数据库中，导致数据不一致</li>
</ol>
</li>
<li><p>改进方式</p>
<p>暂无。</p>
</li>
</ul>
<ol start="4">
<li>更新数据库 -&gt; 删除缓存</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610163933.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">query1 -&gt; DB: select data</span><br><span class="line">transaction1 -&gt; DB: update result</span><br><span class="line">transaction1 -&gt; Cache: delete data</span><br><span class="line">query1 -&gt; Cache: insert data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li><p>可能出现的数据不一致</p>
<p>查询请求先拿到数据，在插入缓存前更新请求进来更新数据库并使缓存失效，这个请求比较罕见</p>
<ol>
<li>发生的场景<ol>
<li>查询请求所在机器请求缓存比更新请求做完的整个流程都要慢</li>
</ol>
</li>
<li>发生的概率<ol>
<li>很低。因为操作缓存一般会比操作数据库要快</li>
</ol>
</li>
</ol>
</li>
<li><p>改进方式</p>
<ol>
<li>变更数据记录变更事件<ol>
<li>步骤<ol>
<li>更新数据同步记录一个事件在本地内存中</li>
<li>查询请求在插入缓存前查询事件，如果存在变更则查数据库获取最新数据</li>
<li>如果此数据在查询请求插入缓存过程中一直变更，这里需要先返回当前数据库结果给上游，再开异步任务轮训事件&#x2F;数据库插入缓存</li>
</ol>
</li>
<li>适用场景<ol>
<li>只适用单节点</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="Server-维护缓存-amp-数据库的一致性"><a href="#Server-维护缓存-amp-数据库的一致性" class="headerlink" title="Server 维护缓存 &amp; 数据库的一致性"></a>Server 维护缓存 &amp; 数据库的一致性</h4><ol>
<li><p>Read though&#x2F;Write though</p>
<ul>
<li>read though</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610164000.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">query -&gt; repository: select data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: get data</span><br><span class="line">repository -&gt; DB: get data</span><br><span class="line">DB -&gt; repository: return data</span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line">repository -&gt; query: return data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li>wirte though</li>
</ul>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610164021.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transcation -&gt; repository: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line">repository -&gt; DB: update data</span><br><span class="line">DB -&gt; repository: return result</span><br><span class="line">repository -&gt; transcation: return result</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>可能出现的数据不一致<ul>
<li>程序没有优雅关闭，更新请求先更新了缓存，但还没更新数据库，数据丢失</li>
<li>更新缓存成功，更新数据库失败导致的数据不一致</li>
</ul>
</li>
<li>适用场景<ul>
<li>更新数据库极低概率失败</li>
<li>程序有优雅关闭功能</li>
</ul>
</li>
<li>改进方式<ul>
<li>暂无</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Write Behind</li>
</ol>
<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610165345.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">query -&gt; repository: query data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: query data</span><br><span class="line">repository -&gt; DB: query data</span><br><span class="line">DB -&gt; repository: return data</span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; query: return data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<p><img src="https://raw.githubusercontent.com/cartoonYu/cartoon-blog-image/cache_consistent/20230610165405.png"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@startuml</span><br><span class="line">Database Database   as DB</span><br><span class="line">entity   Cache      as Cache</span><br><span class="line"></span><br><span class="line">transcation -&gt; repository: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; cache: update data</span><br><span class="line"></span><br><span class="line">repository -&gt; DB: batch update data</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>



<ul>
<li>可能出现的数据不一致<ul>
<li>程序没有优雅关闭，更新请求先更新了缓存，但还没更新数据库，数据丢失</li>
<li>批量更新数据库失败导致的数据不一致</li>
</ul>
</li>
<li>适用场景<ul>
<li>更新数据库极低概率失败</li>
<li>程序有优雅关闭功能</li>
</ul>
</li>
<li>改进方式<ul>
<li>暂无</li>
</ul>
</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a target="_blank" rel="noopener" href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a></p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2023/04/30/message%20queue/kafka%20%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/04/30/message%20queue/kafka%20%E4%B8%8D%E6%94%AF%E6%8C%81%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E7%9A%84%E5%8E%9F%E5%9B%A0/" class="post-title-link" itemprop="url">kafka 不支持读写分离的原因</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-04-30 16:41:19" itemprop="dateCreated datePublished" datetime="2023-04-30T16:41:19+00:00">2023-04-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前段时间在看 kafka 相关内容，发现 kafka “所有的”读写流量都在主 partition 上，从 partition 只负责备份数据。</p>
<blockquote>
<p>那么为什么 kafka 从 partition 不跟其他中间件一样承接读流量？</p>
</blockquote>
<h3 id="读写分离的初衷"><a href="#读写分离的初衷" class="headerlink" title="读写分离的初衷"></a>读写分离的初衷</h3><p>读写分离的初衷我觉得是利用读流量 &amp; 写流量不同的特性做针对性的优化，而这两种流量我觉得区别如下</p>
<table>
<thead>
<tr>
<th></th>
<th>读流量</th>
<th>写流量</th>
</tr>
</thead>
<tbody><tr>
<td>业务特性</td>
<td>展示类的业务</td>
<td>操作类业务</td>
</tr>
<tr>
<td>流量占比</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>可接受数据延迟</td>
<td>较大</td>
<td>非常小</td>
</tr>
<tr>
<td>增长的可预见性</td>
<td>高峰&#x2F;安全攻击可能会突发增长</td>
<td>总体平稳</td>
</tr>
</tbody></table>
<h3 id="使用-kafka-的业务特征"><a href="#使用-kafka-的业务特征" class="headerlink" title="使用 kafka 的业务特征"></a>使用 kafka 的业务特征</h3><ol>
<li>操作型业务，consumer 消费 producer 生产的消息，进行自身业务，这个消息就类似于 trigger</li>
<li>可支撑的流量较大，并且可支撑下游 consumer 较多，rebalance 需要一定的时间</li>
</ol>
<h3 id="kafka-架构"><a href="#kafka-架构" class="headerlink" title="kafka 架构"></a>kafka 架构</h3><ol>
<li>以 topic 为单位，一 topic 可拆分多个 partition，每个 partition 都可以有多个从 partition，不同 partition 分布在不同 broker 上</li>
<li>以 partition 为单位，形成 AR（Assigned Repllicas），ISR（In Sync Repllicas），OSR（Out Sync Repllicas），主 partition 接收到消息后按照 ack 策略同步到 ISR 中从 partition<ol>
<li>ack &#x3D; 0，producer 发出消息后就不管了</li>
<li>ack &#x3D; 1，producer 发出消息写入主 partition 所在 broker 的磁盘就算成功</li>
<li>ack &#x3D; all，producer 发出消息写入主 partition 以及 ISR 上所有副 partition 的磁盘才算成功</li>
</ol>
</li>
</ol>
<h3 id="kafka-没有主从读写分离的原因"><a href="#kafka-没有主从读写分离的原因" class="headerlink" title="kafka 没有主从读写分离的原因"></a>kafka 没有主从读写分离的原因</h3><ol>
<li>不能主从读写分离的原因<ol>
<li>kafka 承接的大多是操作型业务，这部分读操作对数据延迟非常敏感。</li>
<li>kafka 主从同步为半同步复制，并且有部分 partition 在 OSR 上，数据延迟较大</li>
<li>kafka 主 partition 接收到消息后，可以根据 ack 策略落盘，如果不是 all 的话存在数据丢失的风险</li>
</ol>
</li>
<li>不需要主从读写分离的原因<ol>
<li>kafka 本身就是多 partition 的架构，不同 parition 在不同的 broker 上，多主节点的结构本身分流了流量</li>
<li>kafka 本身就有成熟的 rebalance 机制，partition 上线与下线都比较无感</li>
</ol>
</li>
</ol>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="https://cartoonyu.github.io/2022/11/15/JAVA/%E5%AF%B9JVM-G1%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="cartoon Yu">
      <meta itemprop="description" content="do what I like, love who I love">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="cartoon's blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/15/JAVA/%E5%AF%B9JVM-G1%E7%9A%84%E7%90%86%E8%A7%A3/" class="post-title-link" itemprop="url">对JVM G1的理解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-15 00:24:02" itemprop="dateCreated datePublished" datetime="2022-11-15T00:24:02+00:00">2022-11-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-07-13 17:21:28" itemprop="dateModified" datetime="2025-07-13T17:21:28+00:00">2025-07-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>NOTICE：本文仅记录本人对 JVM G1 的小小理解，没有详细记录每个点，若有误可指出</p>
</blockquote>
<h4 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h4><p>G1 将堆分为各个 region，大小通过 G1HeapRegionSize 指定</p>
<h5 id="region-分类"><a href="#region-分类" class="headerlink" title="region 分类"></a>region 分类</h5><h6 id="按-region-大小分"><a href="#按-region-大小分" class="headerlink" title="按 region 大小分"></a>按 region 大小分</h6><ol>
<li>普通 region，存放大小小于普通 refion 容量的一半的对象</li>
<li>humongous 区域，存放大对象</li>
</ol>
<h6 id="按功能来分"><a href="#按功能来分" class="headerlink" title="按功能来分"></a>按功能来分</h6><ol>
<li>新老代</li>
<li>老年代（humongous 只能在老年代）</li>
</ol>
<h4 id="新对象进入"><a href="#新对象进入" class="headerlink" title="新对象进入"></a>新对象进入</h4><ol>
<li>新对象根据大小进入普通 region &#x2F;humongous </li>
<li>记忆集维护<ol>
<li>本 region 维护一个记忆集，记忆集都是别的 region 对象指向本 region 的引用</li>
<li>写前屏障，处理 SATB，将修改前引用对象放入 SATB 队列</li>
<li>写后屏障，标记被修改的对象所在卡表为 dirty card</li>
</ol>
</li>
</ol>
<h4 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h4><h5 id="回收依据"><a href="#回收依据" class="headerlink" title="回收依据"></a>回收依据</h5><p>维护每个 region 中垃圾的价值（回收获得的空间大小以及所需时间的比值）大小，通过最大 GC 时间（-XX:MaxGCPauseMillis）优先处理价值大的 region</p>
<h5 id="回收分类"><a href="#回收分类" class="headerlink" title="回收分类"></a>回收分类</h5><ol>
<li>Young GC</li>
<li>Mixed GC（老年代中的内存比例超过IHOP）</li>
</ol>
<h5 id="回收步骤"><a href="#回收步骤" class="headerlink" title="回收步骤"></a>回收步骤</h5><ol>
<li>初始标记<ol>
<li>标记 GC Root 直接关联的对象</li>
<li>生成原始快照</li>
<li>修改 TAMS 的值</li>
<li>需要 Stop the world</li>
</ol>
</li>
<li>并发标记<ol>
<li>从 GC Root 开始进行可达性分析</li>
<li>处理 SATB 记录的引用变动的对象</li>
</ol>
</li>
<li>最终标记<ol>
<li>处于并发阶段遗留的少量 SATB 记录</li>
</ol>
</li>
<li>筛选回收<ol>
<li>计算各个 region 回收价值</li>
<li>回收<ol>
<li>将回收 region 中存活对象挪到空 region 中</li>
<li>清空原有 region</li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="标记过程中问题处理"><a href="#标记过程中问题处理" class="headerlink" title="标记过程中问题处理"></a>标记过程中问题处理</h5><ol>
<li>在并发标记中，有新对象生成<ol>
<li>通过 TAMS 划分特定区域</li>
<li>新对象只能放在 TAMS 区域中，并且默认是黑色的</li>
</ol>
</li>
<li>在并发标记进行可达性分析，引用变动的对象处理<ol>
<li>使用 SATB 记录灰色到白色删除的引用</li>
<li>在最终标记以灰色的对象为根，重新扫描一次</li>
</ol>
</li>
</ol>
<h5 id="停顿分析"><a href="#停顿分析" class="headerlink" title="停顿分析"></a>停顿分析</h5><ol>
<li>初始标记是 STW 的，但是只标记 GC Root，所以停顿时间较短</li>
<li>并发标记因为是与应用线程并发进行的，所以即使需要进行可达性分析，但是也不会停顿</li>
<li>最终标记，因为并发标记漏的对象比较少，所以即使 STW，停顿也不长</li>
<li>筛选回收，因为 G1 实际是用的是复制算法，复制对象时间可能较长，所以耗时较多是在此阶段</li>
</ol>
<h4 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h4><h5 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h5><ol>
<li>黑色意义为被访问过的对象，引用都扫描过，并且确认最后是存活的，GC Root 默认为黑色</li>
<li>灰色意义为被访问过的对象，有一个引用未被扫描过，未确定是否存活</li>
<li>白色意义为未被访问过的对象</li>
</ol>
<h5 id="对并发标记中对象引用变化处理"><a href="#对并发标记中对象引用变化处理" class="headerlink" title="对并发标记中对象引用变化处理"></a>对并发标记中对象引用变化处理</h5><h6 id="SATB"><a href="#SATB" class="headerlink" title="SATB"></a>SATB</h6><ol>
<li>全称为 Snapshot At The Beginning</li>
<li>Region 包含 5 个指针<ol>
<li>bottom</li>
<li>previous TAMS</li>
<li>next TAMS</li>
<li>top</li>
<li>end</li>
</ol>
</li>
<li>作用流程<ol>
<li>并发标记中，新创建的对象在 next TAMS -&gt; top 之间，此区间默认为黑色，默认存活</li>
<li>灰色对象删除指向白色的引用，记录下来</li>
<li>以记录下来的灰色为根，重新扫描</li>
</ol>
</li>
</ol>
<h6 id="Incremental-Update"><a href="#Incremental-Update" class="headerlink" title="Incremental Update"></a>Incremental Update</h6><ol>
<li>黑色插入新的指向白色的引用，记录下来</li>
<li>并发扫描结束后，以记录下来的黑色为根，重新扫描一遍</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://blog.51cto.com/u_15072811/4679940">https://blog.51cto.com/u_15072811/4679940</a></p>
<p><strong>本文首发于<a href="https://cartoonyu.github.io/">cartoon的博客</a></strong></p>
<p><strong>转载请注明出处:<a href="https://cartoonyu.github.io/">https://cartoonyu.github.io</a></strong></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">cartoon Yu</p>
  <div class="site-description" itemprop="description">do what I like, love who I love</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">48</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="sidebar-button motion-element"><i class="fa fa-comment"></i>
    Chat
  </a>
  </div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/cartoonYu" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;cartoonYu" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:cartoonyu3@gmail.com" title="E-Mail → mailto:cartoonyu3@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://blog.csdn.net/cartoon_?spm=1010.2135.3001.5421" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;cartoon_?spm&#x3D;1010.2135.3001.5421" rel="noopener" target="_blank"><i class=" fa-fw"></i>CSDN</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://segmentfault.com/u/cartoon_5cce2e0fb8fae" title="Segmentfault → https:&#x2F;&#x2F;segmentfault.com&#x2F;u&#x2F;cartoon_5cce2e0fb8fae" rel="noopener" target="_blank"><i class=" fa-fw"></i>Segmentfault</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="https://github.com/theme-next/hexo-theme-next" title="https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next" rel="noopener" target="_blank">Link1</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://blog.csdn.net/Fosu_Chenai/article/details/111155327" title="https:&#x2F;&#x2F;blog.csdn.net&#x2F;Fosu_Chenai&#x2F;article&#x2F;details&#x2F;111155327" rel="noopener" target="_blank">Link2</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://zhuanlan.zhihu.com/p/351031589" title="https:&#x2F;&#x2F;zhuanlan.zhihu.com&#x2F;p&#x2F;351031589" rel="noopener" target="_blank">Link3</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">cartoon Yu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


</body>
</html>
